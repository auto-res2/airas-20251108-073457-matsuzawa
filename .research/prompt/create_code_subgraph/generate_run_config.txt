
LLM Name: o3-2025-04-16
Input:
You are an AI research assistant tasked with generating Hydra configuration files for experiment runs.

# Task
Generate individual YAML configuration files for each experiment run. These configs will be used by Hydra to configure specific experimental variations.

# Input Information

## Hypothesis
open_problems='Parameter-efficient continual tuning today juggles three conflicting goals: (i) no catastrophic forgetting, (ii) constant memory w.r.t. layers *and* tasks, (iii) data-free privacy preservation.  LILAC shows this is doable for up to four English classification tasks, but leaves open: 1) scaling to dozens of heterogeneous tasks (generation, code, multilingual), 2) principled allocation of its tiny dictionary across tasks, 3) theoretical guarantee that the adapter norm—and hence interference—cannot diverge after long streams, 4) adaptation latency on CPU-class edge devices.  A method that simultaneously addresses these four gaps is missing.' method='HIMALAYA – HIerarchical Memory-Allocating LAyer-free Adapter.\nCore ideas.\n1. Two–tier dictionary: a fixed "core" D_c (k_c=24) initialised isotropically and a small "elastic" pool D_e (k_e≤16) managed by a learnable KD-Tree.  Both are layer-free.\n2. Self–normalising update: for every token we apply  \\hat W_ℓ = W_ℓ + (D_c U + D_e V) (D_c U + D_e V)^T / √d  , where U,V are sparse coefficient vectors.  L2 norm of each new update is forced to 1 via an analytical rescaling, preventing norm explosion.\n3. Budgeted elastic growth: when average cosine similarity between recent residuals and existing atoms <τ for 200 steps, we promote the residual’s top singular vector into D_e, then immediately prune the least-used atom so |D_e| stays constant.\n4. Meta–prioritised replay-free consolidation: before overwriting an atom we run a 20-step closed-form Fisher orthogonal projection to imprint its knowledge into the core latent U statistics; this needs only gradients, not data.\n5. CPU-aware quantised inference: both D_c and D_e stored in 3-bit smooth quantisation; U,V kept as int8 indices.\n6. Hyper-router H_θ (≈45 k params) produces Bernoulli(π) gates and coefficients from CLS+task embedding; π is temperature-annealed so expected active atoms per token ≤3, guaranteeing <4 % extra FLOPs.\nParameter count: |D_c|+|D_e|+|θ|+ring buffer (4×32) <2.5 MB @8-bit.' experimental_setup='Backbone: Llama-2-7B-HF (4-bit QLoRA).\nTask stream (25 tasks, never revisited):\n• EN→DE translation (WMT14, 50 k)\n• GLUE-RTE\n• Summarisation (CNN/DailyMail 30 k)\n• TyDiQA-goldp (sw, fi)\n• Code-Alpaca 20 k\n• BoolQ noisy\n… (full list in repo, mixture of classification, QA, generation, code, 10 languages).\nBaselines: LoRA-8, COLTAS, LILAC, ReFT-LoRe, GloDiS-64 (all with replay-free EWC).\nMetrics after each task: current score (task-specific), average retained accuracy over all past tasks, forgetting Δ, memory (MB), wall-clock latency on Raspberry Pi 4 CPU.\nPrimary runs 1 seed, plus 3-task ablation for 3 seeds (≤24 h on single RTX 4090). Code ≤400 LoC PyTorch 2.1, pure Python.' primary_metric='Area-Under-Curve of ‘retained-accuracy vs tasks’ ↑; secondary – CPU latency overhead ↓' experimental_code='https://github.com/anon/himalaya_adapter  (pip-installable, no custom CUDA)' expected_result='1) After 25 tasks HIMALAYA keeps ≤1.5 pp average forgetting vs 5–8 pp (LoRA) and 2.7 pp (LILAC/COLTAS).\n2) Final mean performance 1-3 pp above LILAC on classification, +0.6 BLEU on WMT EN→DE, +1.4 ROUGE-L summarisation.\n3) Extra storage fixed at 2.3 MB, peak Pi-4 latency +7 % (others +20 % or cannot run due to memory).\n4) Atom norm remains bounded ≤1.05 for entire stream, confirming theoretical guarantee.' expected_conclusion='A two-tier, self-normalising spectral dictionary with on-the-fly KD-Tree managed growth enables layer-free adapters to survive 25 heterogeneous tasks under a strict 2.5 MB budget and edge-CPU constraints, advancing continual PEFT beyond current LILAC/COLTAS limits while providing the first bounded-norm guarantee for replay-free adaptation.'

## Research Method
HIMALAYA – HIerarchical Memory-Allocating LAyer-free Adapter.
Core ideas.
1. Two–tier dictionary: a fixed "core" D_c (k_c=24) initialised isotropically and a small "elastic" pool D_e (k_e≤16) managed by a learnable KD-Tree.  Both are layer-free.
2. Self–normalising update: for every token we apply  \hat W_ℓ = W_ℓ + (D_c U + D_e V) (D_c U + D_e V)^T / √d  , where U,V are sparse coefficient vectors.  L2 norm of each new update is forced to 1 via an analytical rescaling, preventing norm explosion.
3. Budgeted elastic growth: when average cosine similarity between recent residuals and existing atoms <τ for 200 steps, we promote the residual’s top singular vector into D_e, then immediately prune the least-used atom so |D_e| stays constant.
4. Meta–prioritised replay-free consolidation: before overwriting an atom we run a 20-step closed-form Fisher orthogonal projection to imprint its knowledge into the core latent U statistics; this needs only gradients, not data.
5. CPU-aware quantised inference: both D_c and D_e stored in 3-bit smooth quantisation; U,V kept as int8 indices.
6. Hyper-router H_θ (≈45 k params) produces Bernoulli(π) gates and coefficients from CLS+task embedding; π is temperature-annealed so expected active atoms per token ≤3, guaranteeing <4 % extra FLOPs.
Parameter count: |D_c|+|D_e|+|θ|+ring buffer (4×32) <2.5 MB @8-bit.

## Experimental Design
experiment_summary='This experiment evaluates HIMALAYA, a 2.5-MB layer-free continual-learning adapter, on a long non-repeating stream of 25 heterogeneous NLP tasks. A 4-bit-quantised Llama-2-7B-HF serves as the frozen backbone while HIMALAYA is the only part trained. After every task we log task-specific quality, averaged retained accuracy on all previously-seen tasks, forgetting, extra memory and Raspberry-Pi-4 inference latency. AUC of retained-accuracy-vs-tasks is the primary metric. We compare HIMALAYA to the strongest replay-free PEFT baseline, LILAC. Hyper-parameters (learning rate, similarity threshold τ, KD-Tree fan-out, etc.) are tuned with a small validation stream. All code is PyTorch-2.1 and runs in <24 h on one NVIDIA A100 (80 GB).\n\nData: because no single public corpus covers such a stream, we build a “Continual Task Stream 25” collection that concatenates WMT14-EN→DE, GLUE-RTE, CNN/DM summarisation, TyDiQA-goldp (Swahili & Finnish), Code-Alpaca 20 k, BoolQ-noisy, and 19 more classification, QA, generation and code datasets covering 10 languages. Each dataset is shown once, then never revisited; samples are capped at 50 k per task to keep training time constant.\n\nWorkflow:\n1. Initialise 4-bit QLoRA weights of Llama-2-7B and freeze them.\n2. Instantiate HIMALAYA: 24-atom core dictionary D_c, 16-slot elastic dictionary D_e with KD-Tree index, 45 k-parameter hyper-router H_θ, and a 128-vector ring buffer for residual statistics. All tensors are stored in 3- or 8-bit quantisation.\n3. For each incoming task T_i:\n   a. Train for one epoch (max 50 k updates) using AdamW and the self-normalising update rule.\n   b. Whenever the mean residual similarity < τ for 200 steps, add the principal residual vector to D_e and prune the least-used atom, followed by Fisher consolidation into D_c.\n   c. At task end, log metrics on T_i’s validation split and on all previously-seen tasks without replay.\n4. After finishing the 25-task stream, compute AUC of retained accuracy, final forgetting, total extra memory, and Raspberry-Pi-4 latency.\n\nHardware: training uses one A100 80 GB (fits backbone + adapter gradients easily); inference latency is measured by exporting the adapter to ONNX-runtime-CPU and running on a Raspberry Pi 4 (4 GB RAM).\n\nExpected outcome: HIMALAYA will maintain ≤ 1.5 pp average forgetting (vs ≥ 2.7 pp for LILAC) with only 2.3 MB extra memory and < 7 % latency overhead on the Pi-4, validating the hypothesis that its two-tier self-normalising dictionary prevents catastrophic forgetting while respecting a strict memory and CPU budget.' evaluation_metrics=['Area-Under-Curve of retained-accuracy vs tasks', 'Average Forgetting Δ', 'Task-specific Accuracy', 'BLEU', 'ROUGE-L', 'Exact Match', 'F1 Score', 'CPU latency overhead', 'Area-Under-Curve of ‘retained-accuracy vs tasks’ ↑; secondary – CPU latency overhead ↓'] proposed_method='HIMALAYA (HIerarchical Memory-Allocating LAyer-free Adapter) attaches a tiny layer-agnostic residual correction to every transformer layer without adding new trainable matrices.\nComponents:\n1. Two-tier dictionary: a fixed 24-vector isotropic core D_c and a 16-slot elastic dictionary D_e organised by a learnable KD-Tree for fast nearest-neighbour search.\n2. Self-normalising spectral update: for every token, compute r = (D_c U + D_e V); inject an outer-product r r^T /√d into the current layer weight W_ℓ. A closed-form rescaling enforces ‖r‖₂ = 1, guaranteeing bounded adapter norm.\n3. Budgeted elastic growth: monitor cosine similarity between incoming residuals and existing atoms; if the trailing 200-step mean drops below τ, promote the dominant residual direction into D_e and evict the least-used atom so |D_e| stays constant.\n4. Meta-prioritised replay-free consolidation: before an atom is evicted, a 20-step closed-form Fisher projection transfers its information into the running statistics of U, requiring gradients only—no raw data—thus preserving privacy.\n5. Quantised, CPU-aware storage: D_c and D_e are stored in 3-bit smooth quantisation; sparse coefficient indices U,V are 8-bit; H_θ (≈45 k params) outputs Bernoulli gates and coefficients from a CLS token and task embedding, annealed so ≤ 3 atoms activate per token, adding < 4 % FLOPs.\n6. Total trainable footprint: < 2.5 MB at 8-bit, constant in both number of layers and tasks.\nTraining: only HIMALAYA’s parameters (D_e, KD-Tree splits, H_θ) and sparse routing logits receive gradients. Optimiser: AdamW with linear warm-up.\nInference: the adapter is exported to a small ONNX custom op that reconstructs r on-the-fly using int8 look-ups, making it viable on Raspberry Pi-class CPUs.' comparative_methods=['LILAC (Layer-Integrated Low-rank Adapter for Continual learning)'] models_to_use=['Llama-2-7B-HF (4-bit QLoRA, 7 B parameters)'] datasets_to_use=[] hyperparameters_to_search={'learning_rate': '1e-5-3e-4', 'tau_similarity_threshold': '0.75-0.9', 'kd_tree_fanout': '4,8,16', 'router_temperature_init': '0.5-2.0', 'adamw_weight_decay': '0-0.01'} external_resources=ExternalResources(hugging_face=HuggingFace(models=[HuggingFaceResource(id='NousResearch/Llama-2-7b-hf', author='NousResearch', sha='8efe6c9b93655b934e27bd9981e3ec13e55aee9d', created_at=datetime.datetime(2023, 7, 18, 18, 30, 59, tzinfo=TzInfo(UTC)), last_modified=datetime.datetime(2024, 6, 3, 19, 23, 18, tzinfo=TzInfo(UTC)), private=False, gated=False, disabled=False, downloads=80497, likes=162, siblings=[HuggingFaceSibling(rfilename='.gitattributes', size=None, blob_id=None, lfs=None), HuggingFaceSibling(rfilename='LICENSE.txt', size=None, blob_id=None, lfs=None), HuggingFaceSibling(rfilename='README.md', size=None, blob_id=None, lfs=None), HuggingFaceSibling(rfilename='Responsible-Use-Guide.pdf', size=None, blob_id=None, lfs=None), HuggingFaceSibling(rfilename='USE_POLICY.md', size=None, blob_id=None, lfs=None), HuggingFaceSibling(rfilename='config.json', size=None, blob_id=None, lfs=None), HuggingFaceSibling(rfilename='generation_config.json', size=None, blob_id=None, lfs=None), HuggingFaceSibling(rfilename='model-00001-of-00002.safetensors', size=None, blob_id=None, lfs=None), HuggingFaceSibling(rfilename='model-00002-of-00002.safetensors', size=None, blob_id=None, lfs=None), HuggingFaceSibling(rfilename='model.safetensors.index.json', size=None, blob_id=None, lfs=None)], card_data=HuggingFaceCardData(license=None, language=['en'], library_name=None, pipeline_tag='text-generation', tags=['facebook', 'meta', 'pytorch', 'llama', 'llama-2'], datasets=[], model_type=None, base_model=None, task_categories=[], size_categories=[], metrics=[], widget=[]), tags=['transformers', 'pytorch', 'safetensors', 'llama', 'text-generation', 'facebook', 'meta', 'llama-2', 'en', 'autotrain_compatible', 'text-generation-inference', 'region:us'], pipeline_tag='text-generation', library_name='transformers', readme="---\nextra_gated_heading: Access Llama 2 on Hugging Face\nextra_gated_description: >-\n  This is a form to enable access to Llama 2 on Hugging Face after you have been\n  granted access from Meta. Please visit the [Meta website](https://ai.meta.com/resources/models-and-libraries/llama-downloads) and accept our\n  license terms and acceptable use policy before submitting this form. Requests\n  will be processed in 1-2 days.\nextra_gated_button_content: Submit\nextra_gated_fields:\n  I agree to share my name, email address and username with Meta and confirm that I have already been granted download access on the Meta website: checkbox\nlanguage:\n- en\npipeline_tag: text-generation\ninference: false\ntags:\n- facebook\n- meta\n- pytorch\n- llama\n- llama-2\n---\n# **Llama 2**\nLlama 2 is a collection of pretrained and fine-tuned generative text models ranging in scale from 7 billion to 70 billion parameters. This is the repository for the 7B pretrained model, converted for the Hugging Face Transformers format. Links to other models can be found in the index at the bottom.\n\n## Model Details\n*Note: Use of this model is governed by the Meta license. In order to download the model weights and tokenizer, please visit the [website](https://ai.meta.com/resources/models-and-libraries/llama-downloads/) and accept our License before requesting access here.*\n\nMeta developed and publicly released the Llama 2 family of large language models (LLMs), a collection of pretrained and fine-tuned generative text models ranging in scale from 7 billion to 70 billion parameters. Our fine-tuned LLMs, called Llama-2-Chat, are optimized for dialogue use cases. Llama-2-Chat models outperform open-source chat models on most benchmarks we tested, and in our human evaluations for helpfulness and safety, are on par with some popular closed-source models like ChatGPT and PaLM.\n\n**Model Developers** Meta\n\n**Variations** Llama 2 comes in a range of parameter sizes — 7B, 13B, and 70B — as well as pretrained and fine-tuned variations.\n\n**Input** Models input text only.\n\n**Output** Models generate text only.\n\n**Model Architecture** Llama 2 is an auto-regressive language model that uses an optimized transformer architecture. The tuned versions use supervised fine-tuning (SFT) and reinforcement learning with human feedback (RLHF) to align to human preferences for helpfulness and safety.\n\n\n||Training Data|Params|Content Length|GQA|Tokens|LR|\n|---|---|---|---|---|---|---|\n|Llama 2|*A new mix of publicly available online data*|7B|4k|&#10007;|2.0T|3.0 x 10<sup>-4</sup>|\n|Llama 2|*A new mix of publicly available online data*|13B|4k|&#10007;|2.0T|3.0 x 10<sup>-4</sup>|\n|Llama 2|*A new mix of publicly available online data*|70B|4k|&#10004;|2.0T|1.5 x 10<sup>-4</sup>|\n\n*Llama 2 family of models.* Token counts refer to pretraining data only. All models are trained with a global batch-size of 4M tokens. Bigger models -  70B -- use Grouped-Query Attention (GQA) for improved inference scalability.\n\n**Model Dates** Llama 2 was trained between January 2023 and July 2023.\n\n**Status** This is a static model trained on an offline dataset. Future versions of the tuned models will be released as we improve model safety with community feedback.\n\n**License** A custom commercial license is available at: [https://ai.meta.com/resources/models-and-libraries/llama-downloads/](https://ai.meta.com/resources/models-and-libraries/llama-downloads/)\n\n## Intended Use\n**Intended Use Cases** Llama 2 is intended for commercial and research use in English. Tuned models are intended for assistant-like chat, whereas pretrained models can be adapted for a variety of natural language generation tasks.\n\nTo get the expected features and performance for the chat versions, a specific formatting needs to be followed, including the `INST` and `<<SYS>>` tags, `BOS` and `EOS` tokens, and the whitespaces and breaklines in between (we recommend calling `strip()` on inputs to avoid double-spaces). See our reference code in github for details: [`chat_completion`](https://github.com/facebookresearch/llama/blob/main/llama/generation.py#L212).\n\n**Out-of-scope Uses** Use in any manner that violates applicable laws or regulations (including trade compliance laws).Use in languages other than English. Use in any other way that is prohibited by the Acceptable Use Policy and Licensing Agreement for Llama 2.\n\n## Hardware and Software\n**Training Factors** We used custom training libraries, Meta's Research Super Cluster, and production clusters for pretraining. Fine-tuning, annotation, and evaluation were also performed on third-party cloud compute.\n\n**Carbon Footprint** Pretraining utilized a cumulative 3.3M GPU hours of computation on hardware of type A100-80GB (TDP of 350-400W). Estimated total emissions were 539 tCO2eq, 100% of which were offset by Meta’s sustainability program.\n\n||Time (GPU hours)|Power Consumption (W)|Carbon Emitted(tCO<sub>2</sub>eq)|\n|---|---|---|---|\n|Llama 2 7B|184320|400|31.22|\n|Llama 2 13B|368640|400|62.44|\n|Llama 2 70B|1720320|400|291.42|\n|Total|3311616||539.00|\n\n**CO<sub>2</sub> emissions during pretraining.** Time: total GPU time required for training each model. Power Consumption: peak power capacity per GPU device for the GPUs used adjusted for power usage efficiency. 100% of the emissions are directly offset by Meta's sustainability program, and because we are openly releasing these models, the pretraining costs do not need to be incurred by others.\n\n## Training Data\n**Overview** Llama 2 was pretrained on 2 trillion tokens of data from publicly available sources. The fine-tuning data includes publicly available instruction datasets, as well as over one million new human-annotated examples. Neither the pretraining nor the fine-tuning datasets include Meta user data.\n\n**Data Freshness** The pretraining data has a cutoff of September 2022, but some tuning data is more recent, up to July 2023.\n\n## Evaluation Results\n\nIn this section, we report the results for the Llama 1 and Llama 2 models on standard academic benchmarks.For all the evaluations, we use our internal evaluations library.\n\n|Model|Size|Code|Commonsense Reasoning|World Knowledge|Reading Comprehension|Math|MMLU|BBH|AGI Eval|\n|---|---|---|---|---|---|---|---|---|---|\n|Llama 1|7B|14.1|60.8|46.2|58.5|6.95|35.1|30.3|23.9|\n|Llama 1|13B|18.9|66.1|52.6|62.3|10.9|46.9|37.0|33.9|\n|Llama 1|33B|26.0|70.0|58.4|67.6|21.4|57.8|39.8|41.7|\n|Llama 1|65B|30.7|70.7|60.5|68.6|30.8|63.4|43.5|47.6|\n|Llama 2|7B|16.8|63.9|48.9|61.3|14.6|45.3|32.6|29.3|\n|Llama 2|13B|24.5|66.9|55.4|65.8|28.7|54.8|39.4|39.1|\n|Llama 2|70B|**37.5**|**71.9**|**63.6**|**69.4**|**35.2**|**68.9**|**51.2**|**54.2**|\n\n**Overall performance on grouped academic benchmarks.** *Code:* We report the average pass@1 scores of our models on HumanEval and MBPP. *Commonsense Reasoning:* We report the average of PIQA, SIQA, HellaSwag, WinoGrande, ARC easy and challenge, OpenBookQA, and CommonsenseQA. We report 7-shot results for CommonSenseQA and 0-shot results for all other benchmarks. *World Knowledge:* We evaluate the 5-shot performance on NaturalQuestions and TriviaQA and report the average. *Reading Comprehension:* For reading comprehension, we report the 0-shot average on SQuAD, QuAC, and BoolQ. *MATH:* We report the average of the GSM8K (8 shot) and MATH (4 shot) benchmarks at top 1.\n\n|||TruthfulQA|Toxigen|\n|---|---|---|---|\n|Llama 1|7B|27.42|23.00|\n|Llama 1|13B|41.74|23.08|\n|Llama 1|33B|44.19|22.57|\n|Llama 1|65B|48.71|21.77|\n|Llama 2|7B|33.29|**21.25**|\n|Llama 2|13B|41.86|26.10|\n|Llama 2|70B|**50.18**|24.60|\n\n**Evaluation of pretrained LLMs on automatic safety benchmarks.** For TruthfulQA, we present the percentage of generations that are both truthful and informative (the higher the better). For ToxiGen, we present the percentage of toxic generations (the smaller the better).\n\n\n|||TruthfulQA|Toxigen|\n|---|---|---|---|\n|Llama-2-Chat|7B|57.04|**0.00**|\n|Llama-2-Chat|13B|62.18|**0.00**|\n|Llama-2-Chat|70B|**64.14**|0.01|\n\n**Evaluation of fine-tuned LLMs on different safety datasets.** Same metric definitions as above.\n\n## Ethical Considerations and Limitations\nLlama 2 is a new technology that carries risks with use. Testing conducted to date has been in English, and has not covered, nor could it cover all scenarios. For these reasons, as with all LLMs, Llama 2’s potential outputs cannot be predicted in advance, and the model may in some instances produce inaccurate, biased or other objectionable responses to user prompts. Therefore, before deploying any applications of Llama 2, developers should perform safety testing and tuning tailored to their specific applications of the model.\n\nPlease see the Responsible Use Guide available at [https://ai.meta.com/llama/responsible-use-guide/](https://ai.meta.com/llama/responsible-use-guide)\n\n## Reporting Issues\nPlease report any software “bug,” or other problems with the models through one of the following means:\n- Reporting issues with the model: [github.com/facebookresearch/llama](http://github.com/facebookresearch/llama)\n- Reporting problematic content generated by the model: [developers.facebook.com/llama_output_feedback](http://developers.facebook.com/llama_output_feedback)\n- Reporting bugs and security concerns: [facebook.com/whitehat/info](http://facebook.com/whitehat/info)\n\n## Llama Model Index\n|Model|Llama2|Llama2-hf|Llama2-chat|Llama2-chat-hf|\n|---|---|---|---|---|\n|7B| [Link](https://huggingface.co/llamaste/Llama-2-7b) | [Link](https://huggingface.co/llamaste/Llama-2-7b-hf) | [Link](https://huggingface.co/llamaste/Llama-2-7b-chat) | [Link](https://huggingface.co/llamaste/Llama-2-7b-chat-hf)|\n|13B| [Link](https://huggingface.co/llamaste/Llama-2-13b) | [Link](https://huggingface.co/llamaste/Llama-2-13b-hf) | [Link](https://huggingface.co/llamaste/Llama-2-13b-chat) | [Link](https://huggingface.co/llamaste/Llama-2-13b-hf)|\n|70B| [Link](https://huggingface.co/llamaste/Llama-2-70b) | [Link](https://huggingface.co/llamaste/Llama-2-70b-hf) | [Link](https://huggingface.co/llamaste/Llama-2-70b-chat) | [Link](https://huggingface.co/llamaste/Llama-2-70b-hf)|", model_index=None, widget_data=None, config=None, transformers_info=None, spaces=None, safetensors=None, used_storage=None, extracted_code='')], datasets=[])) experiment_code=None

## Experiment Runs

- Run ID: proposed-iter1-Llama-2-7B-HF-4-bit-QLoRA-7-B-parameters
  Method: proposed
  Model: Llama-2-7B-HF (4-bit QLoRA, 7 B parameters)
  Dataset: None

- Run ID: comparative-1-iter1-Llama-2-7B-HF-4-bit-QLoRA-7-B-parameters
  Method: comparative-1
  Model: Llama-2-7B-HF (4-bit QLoRA, 7 B parameters)
  Dataset: None


# Requirements

## Configuration Structure
Each run configuration should include:
- run_id: Unique identifier for this run
- method: The method name (baseline, proposed, ablation, etc.)
- model: Model-specific parameters (name, architecture details, hyperparameters)
- dataset: Dataset-specific parameters (name, preprocessing settings, split ratios)
- training: Training hyperparameters (learning rate, batch size, epochs, optimizer settings)
- optuna: Hyperparameter search space definition for Optuna optimization
  - Define search spaces for key hyperparameters using Optuna's suggest methods
  - Example: learning_rate: [1e-5, 1e-3], batch_size: [16, 32, 64]
- Any other experiment-specific settings

## Format
- Generate one YAML configuration per experiment run
- Ensure valid YAML syntax
- Use meaningful parameter values based on the research method and experimental design

## Example Configuration
```yaml
run_id: baseline_bert_imdb
method: baseline
model:
  name: bert-base-uncased
  hidden_size: 768
  num_layers: 12
dataset:
  name: imdb
  max_length: 512
  batch_size: 32
training:
  learning_rate: 2e-5
  epochs: 3
  optimizer: adamw
  warmup_steps: 500
optuna:
  n_trials: 20
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-5
      high: 1e-3
    batch_size:
      type: categorical
      choices: [16, 32, 64]
```

# Experimental Environment
NVIDIA A100 or H200
VRAM: 80 GB or more
RAM: 2048 GB or more

# Instructions
1. Generate one YAML configuration for each experiment run listed above
2. Ensure configurations reflect the differences between baseline, proposed, and ablation methods
3. Use appropriate hyperparameters based on the experimental design
4. Include Optuna search space if hyperparameter optimization is beneficial for the experiment
5. For Optuna search spaces, use appropriate distribution types:
   - loguniform: For learning rates, regularization parameters
   - uniform: For dropout rates, weight decay
   - int: For hidden dimensions, number of layers
   - categorical: For discrete choices like batch size, optimizer type

Generate the configurations now:
Output:
{
  "run_configs": [
    {
      "run_id": "proposed-iter1-Llama-2-7B-HF-4-bit-QLoRA-7-B-parameters",
      "run_config_yaml": "run_id: proposed-iter1-Llama-2-7B-HF-4-bit-QLoRA-7-B-parameters\nmethod: proposed\nmethod_name: HIMALAYA\nmodel:\n  backbone:\n    name: NousResearch/Llama-2-7b-hf\n    quantisation: 4-bit QLoRA\n    frozen: true\n  adapter:\n    type: HIMALAYA\n    core_dictionary:\n      num_atoms: 24\n      init: isotropic\n    elastic_dictionary:\n      max_atoms: 16\n      index: learnable_kd_tree\n      quantisation_bits: 3\n    router:\n      hidden_params: 45000\n      expected_active_atoms: 3\n      temperature_init: 1.0\n    coeff_precision_bits: 8\n    total_parameter_budget_mb: 2.5\n  kd_tree:\n    fanout: 8\n    leaf_size: 4\n  norm_rescaling: true\n\ndataset:\n  name: continual_task_stream_25\n  num_tasks: 25\n  max_samples_per_task: 50000\n  languages: [en, de, sw, fi, multi]\n  tokenizer: NousResearch/Llama-2-7b-hf\n  max_seq_length: 1024\n  streaming: true\n\ntraining:\n  task_epochs: 1\n  max_updates_per_task: 50000\n  batch_size: 8\n  optimizer: adamw\n  learning_rate: 2e-4     # centre of search range; tuned by Optuna\n  weight_decay: 0.001\n  lr_scheduler: linear\n  warmup_steps: 500\n  gradient_checkpointing: true\n  grad_accum_steps: 1\n  similarity_threshold_tau: 0.8\n  fisher_projection_steps: 20\n  router_temperature_anneal: linear\n  mixed_precision: bf16\n\nevaluation:\n  primary_metric: retained_accuracy_auc\n  secondary_metric: cpu_latency_overhead\n  eval_batch_size: 4\n  cpu_latency_device: raspberry-pi-4\n\nhardware:\n  gpu_type: A100-80GB\n  max_gpu_mem_gb: 80\n\noptuna:\n  n_trials: 30\n  direction: maximize\n  search_space:\n    learning_rate:\n      type: loguniform\n      low: 1e-5\n      high: 3e-4\n    similarity_threshold_tau:\n      type: uniform\n      low: 0.75\n      high: 0.9\n    kd_tree_fanout:\n      type: categorical\n      choices: [4, 8, 16]\n    router_temperature_init:\n      type: uniform\n      low: 0.5\n      high: 2.0\n    weight_decay:\n      type: uniform\n      low: 0.0\n      high: 0.01\n"
    },
    {
      "run_id": "comparative-1-iter1-Llama-2-7B-HF-4-bit-QLoRA-7-B-parameters",
      "run_config_yaml": "run_id: comparative-1-iter1-Llama-2-7B-HF-4-bit-QLoRA-7-B-parameters\nmethod: comparative\nmethod_name: LILAC\nmodel:\n  backbone:\n    name: NousResearch/Llama-2-7b-hf\n    quantisation: 4-bit QLoRA\n    frozen: true\n  adapter:\n    type: LILAC\n    lora_rank: 4          # tunable by Optuna\n    dictionary_size: 64\n    ewc_lambda: 0.4       # replay-free regularisation\n    quantisation_bits: 8\n    total_parameter_budget_mb: 3.5\n\ndataset:\n  name: continual_task_stream_25\n  num_tasks: 25\n  max_samples_per_task: 50000\n  tokenizer: NousResearch/Llama-2-7b-hf\n  max_seq_length: 1024\n  streaming: true\n\ntraining:\n  task_epochs: 1\n  max_updates_per_task: 50000\n  batch_size: 8\n  optimizer: adamw\n  learning_rate: 1e-4     # will be tuned\n  weight_decay: 0.0\n  lr_scheduler: linear\n  warmup_steps: 500\n  gradient_checkpointing: true\n  grad_accum_steps: 1\n  mixed_precision: bf16\n\nevaluation:\n  primary_metric: retained_accuracy_auc\n  secondary_metric: cpu_latency_overhead\n  eval_batch_size: 4\n  cpu_latency_device: raspberry-pi-4\n\nhardware:\n  gpu_type: A100-80GB\n  max_gpu_mem_gb: 80\n\noptuna:\n  n_trials: 30\n  direction: maximize\n  search_space:\n    learning_rate:\n      type: loguniform\n      low: 1e-5\n      high: 3e-4\n    lora_rank:\n      type: categorical\n      choices: [4, 8]\n    ewc_lambda:\n      type: loguniform\n      low: 1e-2\n      high: 1.0\n    weight_decay:\n      type: uniform\n      low: 0.0\n      high: 0.01\n"
    }
  ]
}
