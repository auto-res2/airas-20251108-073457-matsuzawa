
LLM Name: o3-2025-04-16
Input:
You are an AI code reviewer validating production-ready experiment code for research papers.

Analyze the provided experiment code and determine if it meets all requirements for immediate execution in research experiments.

# Instructions

## Core Validation Criteria
Check if the generated experiment code meets ALL of the following requirements:

1. **Complete Implementation**:
   - Every component is fully functional, production-ready, publication-worthy code
   - No "omitted for brevity", no "simplified version", no TODO, PLACEHOLDER, pass, or ...
   - All functions and classes are completely implemented
   - No truncated code sections or incomplete implementations

2. **Hydra Integration**:
   - Uses Hydra to manage all experiment configurations from `config/runs/*.yaml` files
   - All parameters are loaded from run configs dynamically
   - Proper configuration structure with run_id, method, model, dataset, training, and optuna sections
   - CLI interface matches:
     * Training (full): `uv run python -u -m src.main run={run_id} results_dir={path} mode=full`
     * Training (trial): `uv run python -u -m src.main run={run_id} results_dir={path} mode=trial`
     * Evaluation: `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2", ...]'` (independent execution)
   - Code must automatically configure based on mode:
     * When `cfg.mode == "trial"`: Set `cfg.wandb.mode = "disabled"`, `cfg.optuna.n_trials = 0`, epochs=1
     * When `cfg.mode == "full"`: Set `cfg.wandb.mode = "online"` and use full configuration

3. **Complete Data Pipeline**:
   - Full data loading and preprocessing implementation
   - Dataset-specific preprocessing is properly implemented
   - No placeholder dataset loading code
   - Proper error handling for data operations
   - Uses `.cache/` as the cache directory for all datasets and models

4. **Model Implementation**:
   - Complete model architectures for all methods (proposed and comparative methods)
   - No placeholders (TODO, PLACEHOLDER, pass, or incomplete implementations)
   - When External Resources specify HuggingFace models: properly use and customize them (acceptable to wrap AutoModel, add adapters, etc.)
   - When no external models specified: implement architectures from scratch using PyTorch primitives
   - Model-specific configurations correctly applied
   - Proper PyTorch usage throughout

5. **File Structure Compliance**:
   - Contains EXACTLY these required files (and NO other files):
     * `src/train.py`
     * `src/evaluate.py`
     * `src/preprocess.py`
     * `src/model.py`
     * `src/main.py`
     * `pyproject.toml`
     * `config/config.yaml`
   - NO additional files (e.g., NO `src/__init__.py`, NO `setup.py`, NO other Python files)
   - No missing files from the structure
   - All functionality contained within specified files

6. **WandB Integration**:
   - train.py initializes WandB and logs ALL metrics comprehensively:
     * Use `wandb.log()` at each training step/batch/epoch with ALL relevant time-series metrics
     * Log as frequently as possible (per-batch or per-epoch) to capture complete training dynamics
     * Use `wandb.summary["key"] = value` to save final/best metrics (best_val_acc, final_test_acc, best_epoch, etc.)
     * Metric names in train.py's wandb.log() MUST exactly match the keys used in evaluate.py's run.history()
   - Optuna Integration: If using Optuna, DO NOT log intermediate trial results to WandB - only log the final run with best hyperparameters
   - Code must automatically configure based on mode:
     * When `cfg.mode == "trial"`: Set `cfg.wandb.mode = "disabled"` before any WandB operations
     * When `cfg.mode == "full"`: Set `cfg.wandb.mode = "online"` before any WandB operations
   - NO results.json or stdout JSON dumps in train.py
   - config/config.yaml contains mandatory WandB settings (entity/project)
   - `WANDB_API_KEY` environment variable is available for authentication

7. **Configuration Files**:
   - The generated code properly references config files via Hydra
   - NOTE: config/runs/{run_id}.yaml files are provided separately (not in ExperimentCode)
   - All run configurations match the experiment_runs provided
   - Optuna search spaces are properly defined if applicable

8. **Evaluation Script Independence**:
   - evaluate.py is executed independently via `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2"]'`
   - Accepts `run_ids` parameter as JSON string list (parse with `json.loads(args.run_ids)`)
   - main.py DOES NOT call evaluate.py
   - evaluate.py loads WandB config from `config/config.yaml` (in repository root)
   - evaluate.py retrieves comprehensive data from WandB API:
     * Use `wandb.Api()` to get run data: `run = api.run(f"{entity}/{project}/{run_id}")`
     * Retrieve: `history = run.history()`, `summary = run.summary._json_dict`, `config = dict(run.config)`
   - **STEP 1: Per-Run Processing** (for each run_id):
     * Export comprehensive run-specific metrics to: `{results_dir}/{run_id}/metrics.json`
     * Generate run-specific figures (learning curves, confusion matrices) to: `{results_dir}/{run_id}/`
     * Each run should have its own subdirectory with its metrics and figures
   - **STEP 2: Aggregated Analysis** (after processing all runs):
     * Export aggregated metrics to: `{results_dir}/comparison/aggregated_metrics.json` with the following structure:
       ```json
       {
         "primary_metric": "Area-Under-Curve of ‘retained-accuracy vs tasks’ ↑; secondary – CPU latency overhead ↓",
         "metrics": {
           "metric_name_1": {"run_id_1": value1, "run_id_2": value2, ...},
           "metric_name_2": {"run_id_1": value1, "run_id_2": value2, ...}
         },
         "best_proposed": {
           "run_id": "proposed-iter2-model-dataset",
           "value": 0.92
         },
         "best_baseline": {
           "run_id": "comparative-1-model-dataset",
           "value": 0.88
         },
         "gap": 4.55
       }
       ```
       The structure must include:
       - "primary_metric": The primary evaluation metric name from the hypothesis
       - "metrics": All collected metrics organized by metric name, then by run_id
       - "best_proposed": The run_id and value of the proposed method with the best primary_metric performance (run_id contains "proposed")
       - "best_baseline": The run_id and value of the baseline/comparative method with the best primary_metric performance (run_id contains "comparative" or "baseline")
       - "gap": Performance gap calculated as: (best_proposed.value - best_baseline.value) / best_baseline.value * 100
         * Must use the expected results from the hypothesis to determine metric direction (higher vs lower is better)
         * If the metric should be minimized, reverse the sign of the gap
         * The gap represents the percentage improvement of the proposed method over the best baseline
     * Generate comparison figures to: `{results_dir}/comparison/`
     * Cross-run comparison charts (bar charts, box plots)
     * Performance metrics tables
     * Statistical significance tests
   - Proper figure quality: legends, annotations, tight_layout
   - Follows GLOBALLY UNIQUE naming convention to prevent collisions:
     * Per-run figures: `{run_id}_{figure_topic}[_<condition>][_pairN].pdf` (e.g., `run-1-proposed-bert-glue_learning_curve.pdf`)
     * Comparison figures: `comparison_{figure_topic}[_<condition>][_pairN].pdf` (e.g., `comparison_accuracy_bar_chart.pdf`)
   - train.py and main.py generate NO figures
   - evaluate.py cannot run in trial_mode (no WandB data available when WandB disabled)

9. **Mode-Based Implementation**:
   - `mode` parameter controls experiment behavior (required parameter)
   - When `cfg.mode == "trial"`:
     * Properly reduces computational load: epochs=1, batches limited to 1-2, Optuna disabled (n_trials=0), small evaluation subset
     * Automatically sets `cfg.wandb.mode = "disabled"`
     * Purpose: Fast validation that code runs without errors
   - When `cfg.mode == "full"`:
     * Automatically sets `cfg.wandb.mode = "online"`
     * Uses full configuration (full epochs, full Optuna trials, etc.)

## Output Format
Respond with a JSON object containing:
- `is_code_ready`: boolean - true if ALL criteria are met, false otherwise
- `code_issue`: string - specific issues found if any criteria are not met, focusing on what needs to be fixed

# Hypothesis
open_problems='Parameter-efficient continual tuning today juggles three conflicting goals: (i) no catastrophic forgetting, (ii) constant memory w.r.t. layers *and* tasks, (iii) data-free privacy preservation.  LILAC shows this is doable for up to four English classification tasks, but leaves open: 1) scaling to dozens of heterogeneous tasks (generation, code, multilingual), 2) principled allocation of its tiny dictionary across tasks, 3) theoretical guarantee that the adapter norm—and hence interference—cannot diverge after long streams, 4) adaptation latency on CPU-class edge devices.  A method that simultaneously addresses these four gaps is missing.' method='HIMALAYA – HIerarchical Memory-Allocating LAyer-free Adapter.\nCore ideas.\n1. Two–tier dictionary: a fixed "core" D_c (k_c=24) initialised isotropically and a small "elastic" pool D_e (k_e≤16) managed by a learnable KD-Tree.  Both are layer-free.\n2. Self–normalising update: for every token we apply  \\hat W_ℓ = W_ℓ + (D_c U + D_e V) (D_c U + D_e V)^T / √d  , where U,V are sparse coefficient vectors.  L2 norm of each new update is forced to 1 via an analytical rescaling, preventing norm explosion.\n3. Budgeted elastic growth: when average cosine similarity between recent residuals and existing atoms <τ for 200 steps, we promote the residual’s top singular vector into D_e, then immediately prune the least-used atom so |D_e| stays constant.\n4. Meta–prioritised replay-free consolidation: before overwriting an atom we run a 20-step closed-form Fisher orthogonal projection to imprint its knowledge into the core latent U statistics; this needs only gradients, not data.\n5. CPU-aware quantised inference: both D_c and D_e stored in 3-bit smooth quantisation; U,V kept as int8 indices.\n6. Hyper-router H_θ (≈45 k params) produces Bernoulli(π) gates and coefficients from CLS+task embedding; π is temperature-annealed so expected active atoms per token ≤3, guaranteeing <4 % extra FLOPs.\nParameter count: |D_c|+|D_e|+|θ|+ring buffer (4×32) <2.5 MB @8-bit.' experimental_setup='Backbone: Llama-2-7B-HF (4-bit QLoRA).\nTask stream (25 tasks, never revisited):\n• EN→DE translation (WMT14, 50 k)\n• GLUE-RTE\n• Summarisation (CNN/DailyMail 30 k)\n• TyDiQA-goldp (sw, fi)\n• Code-Alpaca 20 k\n• BoolQ noisy\n… (full list in repo, mixture of classification, QA, generation, code, 10 languages).\nBaselines: LoRA-8, COLTAS, LILAC, ReFT-LoRe, GloDiS-64 (all with replay-free EWC).\nMetrics after each task: current score (task-specific), average retained accuracy over all past tasks, forgetting Δ, memory (MB), wall-clock latency on Raspberry Pi 4 CPU.\nPrimary runs 1 seed, plus 3-task ablation for 3 seeds (≤24 h on single RTX 4090). Code ≤400 LoC PyTorch 2.1, pure Python.' primary_metric='Area-Under-Curve of ‘retained-accuracy vs tasks’ ↑; secondary – CPU latency overhead ↓' experimental_code='https://github.com/anon/himalaya_adapter  (pip-installable, no custom CUDA)' expected_result='1) After 25 tasks HIMALAYA keeps ≤1.5 pp average forgetting vs 5–8 pp (LoRA) and 2.7 pp (LILAC/COLTAS).\n2) Final mean performance 1-3 pp above LILAC on classification, +0.6 BLEU on WMT EN→DE, +1.4 ROUGE-L summarisation.\n3) Extra storage fixed at 2.3 MB, peak Pi-4 latency +7 % (others +20 % or cannot run due to memory).\n4) Atom norm remains bounded ≤1.05 for entire stream, confirming theoretical guarantee.' expected_conclusion='A two-tier, self-normalising spectral dictionary with on-the-fly KD-Tree managed growth enables layer-free adapters to survive 25 heterogeneous tasks under a strict 2.5 MB budget and edge-CPU constraints, advancing continual PEFT beyond current LILAC/COLTAS limits while providing the first bounded-norm guarantee for replay-free adaptation.'

# Current Research Method
HIMALAYA – HIerarchical Memory-Allocating LAyer-free Adapter.
Core ideas.
1. Two–tier dictionary: a fixed "core" D_c (k_c=24) initialised isotropically and a small "elastic" pool D_e (k_e≤16) managed by a learnable KD-Tree.  Both are layer-free.
2. Self–normalising update: for every token we apply  \hat W_ℓ = W_ℓ + (D_c U + D_e V) (D_c U + D_e V)^T / √d  , where U,V are sparse coefficient vectors.  L2 norm of each new update is forced to 1 via an analytical rescaling, preventing norm explosion.
3. Budgeted elastic growth: when average cosine similarity between recent residuals and existing atoms <τ for 200 steps, we promote the residual’s top singular vector into D_e, then immediately prune the least-used atom so |D_e| stays constant.
4. Meta–prioritised replay-free consolidation: before overwriting an atom we run a 20-step closed-form Fisher orthogonal projection to imprint its knowledge into the core latent U statistics; this needs only gradients, not data.
5. CPU-aware quantised inference: both D_c and D_e stored in 3-bit smooth quantisation; U,V kept as int8 indices.
6. Hyper-router H_θ (≈45 k params) produces Bernoulli(π) gates and coefficients from CLS+task embedding; π is temperature-annealed so expected active atoms per token ≤3, guaranteeing <4 % extra FLOPs.
Parameter count: |D_c|+|D_e|+|θ|+ring buffer (4×32) <2.5 MB @8-bit.

# Experimental Design
- Strategy: This experiment evaluates HIMALAYA, a 2.5-MB layer-free continual-learning adapter, on a long non-repeating stream of 25 heterogeneous NLP tasks. A 4-bit-quantised Llama-2-7B-HF serves as the frozen backbone while HIMALAYA is the only part trained. After every task we log task-specific quality, averaged retained accuracy on all previously-seen tasks, forgetting, extra memory and Raspberry-Pi-4 inference latency. AUC of retained-accuracy-vs-tasks is the primary metric. We compare HIMALAYA to the strongest replay-free PEFT baseline, LILAC. Hyper-parameters (learning rate, similarity threshold τ, KD-Tree fan-out, etc.) are tuned with a small validation stream. All code is PyTorch-2.1 and runs in <24 h on one NVIDIA A100 (80 GB).

Data: because no single public corpus covers such a stream, we build a “Continual Task Stream 25” collection that concatenates WMT14-EN→DE, GLUE-RTE, CNN/DM summarisation, TyDiQA-goldp (Swahili & Finnish), Code-Alpaca 20 k, BoolQ-noisy, and 19 more classification, QA, generation and code datasets covering 10 languages. Each dataset is shown once, then never revisited; samples are capped at 50 k per task to keep training time constant.

Workflow:
1. Initialise 4-bit QLoRA weights of Llama-2-7B and freeze them.
2. Instantiate HIMALAYA: 24-atom core dictionary D_c, 16-slot elastic dictionary D_e with KD-Tree index, 45 k-parameter hyper-router H_θ, and a 128-vector ring buffer for residual statistics. All tensors are stored in 3- or 8-bit quantisation.
3. For each incoming task T_i:
   a. Train for one epoch (max 50 k updates) using AdamW and the self-normalising update rule.
   b. Whenever the mean residual similarity < τ for 200 steps, add the principal residual vector to D_e and prune the least-used atom, followed by Fisher consolidation into D_c.
   c. At task end, log metrics on T_i’s validation split and on all previously-seen tasks without replay.
4. After finishing the 25-task stream, compute AUC of retained accuracy, final forgetting, total extra memory, and Raspberry-Pi-4 latency.

Hardware: training uses one A100 80 GB (fits backbone + adapter gradients easily); inference latency is measured by exporting the adapter to ONNX-runtime-CPU and running on a Raspberry Pi 4 (4 GB RAM).

Expected outcome: HIMALAYA will maintain ≤ 1.5 pp average forgetting (vs ≥ 2.7 pp for LILAC) with only 2.3 MB extra memory and < 7 % latency overhead on the Pi-4, validating the hypothesis that its two-tier self-normalising dictionary prevents catastrophic forgetting while respecting a strict memory and CPU budget.
- Proposed Method: HIMALAYA (HIerarchical Memory-Allocating LAyer-free Adapter) attaches a tiny layer-agnostic residual correction to every transformer layer without adding new trainable matrices.
Components:
1. Two-tier dictionary: a fixed 24-vector isotropic core D_c and a 16-slot elastic dictionary D_e organised by a learnable KD-Tree for fast nearest-neighbour search.
2. Self-normalising spectral update: for every token, compute r = (D_c U + D_e V); inject an outer-product r r^T /√d into the current layer weight W_ℓ. A closed-form rescaling enforces ‖r‖₂ = 1, guaranteeing bounded adapter norm.
3. Budgeted elastic growth: monitor cosine similarity between incoming residuals and existing atoms; if the trailing 200-step mean drops below τ, promote the dominant residual direction into D_e and evict the least-used atom so |D_e| stays constant.
4. Meta-prioritised replay-free consolidation: before an atom is evicted, a 20-step closed-form Fisher projection transfers its information into the running statistics of U, requiring gradients only—no raw data—thus preserving privacy.
5. Quantised, CPU-aware storage: D_c and D_e are stored in 3-bit smooth quantisation; sparse coefficient indices U,V are 8-bit; H_θ (≈45 k params) outputs Bernoulli gates and coefficients from a CLS token and task embedding, annealed so ≤ 3 atoms activate per token, adding < 4 % FLOPs.
6. Total trainable footprint: < 2.5 MB at 8-bit, constant in both number of layers and tasks.
Training: only HIMALAYA’s parameters (D_e, KD-Tree splits, H_θ) and sparse routing logits receive gradients. Optimiser: AdamW with linear warm-up.
Inference: the adapter is exported to a small ONNX custom op that reconstructs r on-the-fly using int8 look-ups, making it viable on Raspberry Pi-class CPUs.
- Evaluation Metrics: ['Area-Under-Curve of retained-accuracy vs tasks', 'Average Forgetting Δ', 'Task-specific Accuracy', 'BLEU', 'ROUGE-L', 'Exact Match', 'F1 Score', 'CPU latency overhead', 'Area-Under-Curve of ‘retained-accuracy vs tasks’ ↑; secondary – CPU latency overhead ↓']

# Experiment Runs

- Run ID: proposed-iter1-Llama-2-7B-HF-4-bit-QLoRA-7-B-parameters
  Method: proposed
  Model: Llama-2-7B-HF (4-bit QLoRA, 7 B parameters)
  Dataset: None
  
  Config Content:
  ```yaml
  run_id: proposed-iter1-Llama-2-7B-HF-4-bit-QLoRA-7-B-parameters
method: proposed
method_name: HIMALAYA
model:
  backbone:
    name: NousResearch/Llama-2-7b-hf
    quantisation: 4-bit QLoRA
    frozen: true
  adapter:
    type: HIMALAYA
    core_dictionary:
      num_atoms: 24
      init: isotropic
    elastic_dictionary:
      max_atoms: 16
      index: learnable_kd_tree
      quantisation_bits: 3
    router:
      hidden_params: 45000
      expected_active_atoms: 3
      temperature_init: 1.0
    coeff_precision_bits: 8
    total_parameter_budget_mb: 2.5
  kd_tree:
    fanout: 8
    leaf_size: 4
  norm_rescaling: true

dataset:
  name: continual_task_stream_25
  num_tasks: 25
  max_samples_per_task: 50000
  languages: [en, de, sw, fi, multi]
  tokenizer: NousResearch/Llama-2-7b-hf
  max_seq_length: 1024
  streaming: true

training:
  task_epochs: 1
  max_updates_per_task: 50000
  batch_size: 8
  optimizer: adamw
  learning_rate: 2e-4     # centre of search range; tuned by Optuna
  weight_decay: 0.001
  lr_scheduler: linear
  warmup_steps: 500
  gradient_checkpointing: true
  grad_accum_steps: 1
  similarity_threshold_tau: 0.8
  fisher_projection_steps: 20
  router_temperature_anneal: linear
  mixed_precision: bf16

evaluation:
  primary_metric: retained_accuracy_auc
  secondary_metric: cpu_latency_overhead
  eval_batch_size: 4
  cpu_latency_device: raspberry-pi-4

hardware:
  gpu_type: A100-80GB
  max_gpu_mem_gb: 80

optuna:
  n_trials: 30
  direction: maximize
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-5
      high: 3e-4
    similarity_threshold_tau:
      type: uniform
      low: 0.75
      high: 0.9
    kd_tree_fanout:
      type: categorical
      choices: [4, 8, 16]
    router_temperature_init:
      type: uniform
      low: 0.5
      high: 2.0
    weight_decay:
      type: uniform
      low: 0.0
      high: 0.01

  ```
  

- Run ID: comparative-1-iter1-Llama-2-7B-HF-4-bit-QLoRA-7-B-parameters
  Method: comparative-1
  Model: Llama-2-7B-HF (4-bit QLoRA, 7 B parameters)
  Dataset: None
  
  Config Content:
  ```yaml
  run_id: comparative-1-iter1-Llama-2-7B-HF-4-bit-QLoRA-7-B-parameters
method: comparative
method_name: LILAC
model:
  backbone:
    name: NousResearch/Llama-2-7b-hf
    quantisation: 4-bit QLoRA
    frozen: true
  adapter:
    type: LILAC
    lora_rank: 4          # tunable by Optuna
    dictionary_size: 64
    ewc_lambda: 0.4       # replay-free regularisation
    quantisation_bits: 8
    total_parameter_budget_mb: 3.5

dataset:
  name: continual_task_stream_25
  num_tasks: 25
  max_samples_per_task: 50000
  tokenizer: NousResearch/Llama-2-7b-hf
  max_seq_length: 1024
  streaming: true

training:
  task_epochs: 1
  max_updates_per_task: 50000
  batch_size: 8
  optimizer: adamw
  learning_rate: 1e-4     # will be tuned
  weight_decay: 0.0
  lr_scheduler: linear
  warmup_steps: 500
  gradient_checkpointing: true
  grad_accum_steps: 1
  mixed_precision: bf16

evaluation:
  primary_metric: retained_accuracy_auc
  secondary_metric: cpu_latency_overhead
  eval_batch_size: 4
  cpu_latency_device: raspberry-pi-4

hardware:
  gpu_type: A100-80GB
  max_gpu_mem_gb: 80

optuna:
  n_trials: 30
  direction: maximize
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-5
      high: 3e-4
    lora_rank:
      type: categorical
      choices: [4, 8]
    ewc_lambda:
      type: loguniform
      low: 1e-2
      high: 1.0
    weight_decay:
      type: uniform
      low: 0.0
      high: 0.01

  ```
  


# Generated Experiment Code (To be validated)
{"config_yaml": "defaults:\n  - _self_\n  - runs: ${run}\n\n# CLI overrides\nrun: null\nresults_dir: outputs\nmode: full\n\nwandb:\n  entity: gengaru617-personal\n  project: 2025-1108-1\n  mode: online\n\n# Fallback placeholders (overwritten by runs/*)\nmodel: {}\ndataset: {}\ntraining: {}\noptuna:\n  n_trials: 0\n  search_space: {}\nevaluation:\n  cpu_latency_device: raspberry-pi-4\n  eval_batch_size: 4\n", "evaluate_py": "import argparse\nimport json\nimport os\nfrom itertools import combinations\nfrom pathlib import Path\nfrom typing import Dict, List\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport wandb\nfrom omegaconf import OmegaConf\nfrom scipy import stats\nfrom sklearn.metrics import ConfusionMatrixDisplay\n\n# -----------------------------------------------------------------------------\n# Helper functions\n# -----------------------------------------------------------------------------\n\n\ndef export_metrics(history: \"pd.DataFrame\", summary: Dict, out_dir: Path):\n    out_dir.mkdir(parents=True, exist_ok=True)\n    p = out_dir / \"metrics.json\"\n    payload = {\"history\": history.to_dict(orient=\"list\"), \"summary\": summary}\n    with open(p, \"w\") as f:\n        json.dump(payload, f, indent=2)\n    return p\n\n\ndef save_confusion_matrices(summary: Dict, out_dir: Path, run_id: str):\n    fig_paths = []\n    for k, v in summary.items():\n        if k.startswith(\"confusion_matrix_\"):\n            task = k[len(\"confusion_matrix_\") :]\n            cm = np.array(v)\n            fig, ax = plt.subplots(figsize=(4, 4))\n            disp = ConfusionMatrixDisplay(confusion_matrix=cm)\n            disp.plot(ax=ax, colorbar=False)\n            plt.title(f\"{run_id} \u2013 {task}\")\n            plt.tight_layout()\n            fp = out_dir / f\"{run_id}_{task}_confusion_matrix.pdf\"\n            fig.savefig(fp)\n            plt.close(fig)\n            fig_paths.append(fp)\n    return fig_paths\n\n\ndef bar_chart(metric_map: Dict[str, float], title: str, out_path: Path):\n    names, vals = zip(*metric_map.items())\n    plt.figure(figsize=(10, 5))\n    sns.barplot(x=list(names), y=list(vals))\n    plt.xticks(rotation=45, ha=\"right\")\n    for i, v in enumerate(vals):\n        plt.text(i, v, f\"{v:.3f}\", ha=\"center\", va=\"bottom\")\n    plt.ylabel(title)\n    plt.title(title)\n    plt.tight_layout()\n    plt.savefig(out_path)\n    plt.close()\n\n\n# -----------------------------------------------------------------------------\n# Main evaluation\n# -----------------------------------------------------------------------------\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"results_dir\", type=str)\n    parser.add_argument(\"run_ids\", type=str, help=\"JSON string list of run IDs\")\n    args = parser.parse_args()\n\n    results_dir = Path(os.path.abspath(args.results_dir))\n    results_dir.mkdir(parents=True, exist_ok=True)\n\n    run_ids: List[str] = json.loads(args.run_ids)\n\n    cfg_root = Path(__file__).resolve().parent.parent / \"config\"\n    cfg_global = OmegaConf.load(cfg_root / \"config.yaml\")\n    entity, project = cfg_global.wandb.entity, cfg_global.wandb.project\n\n    api = wandb.Api()\n\n    aggregated: Dict[str, Dict[str, float]] = {}\n    per_run_artifacts = []\n\n    for rid in run_ids:\n        run = api.run(f\"{entity}/{project}/{rid}\")\n        hist = run.history(samples=50000)  # get all rows\n        summ = dict(run.summary._json_dict)\n        out_dir = results_dir / rid\n        m_path = export_metrics(hist, summ, out_dir)\n        conf_paths = save_confusion_matrices(summ, out_dir, rid)\n        per_run_artifacts.extend([m_path, *conf_paths])\n        # aggregate scalar summary\n        for k, v in summ.items():\n            if isinstance(v, (int, float)):\n                aggregated.setdefault(k, {})[rid] = float(v)\n\n    # ---------------- comparison JSON ----------------\n    primary_metric = \"retained_accuracy_auc\"\n    prim_map = aggregated.get(primary_metric, {})\n    best_prop = {\"run_id\": None, \"value\": -float(\"inf\")}\n    best_base = {\"run_id\": None, \"value\": -float(\"inf\")}\n    for rid, val in prim_map.items():\n        if \"proposed\" in rid:\n            if val \u003e best_prop[\"value\"]:\n                best_prop = {\"run_id\": rid, \"value\": val}\n        if (\"baseline\" in rid) or (\"comparative\" in rid):\n            if val \u003e best_base[\"value\"]:\n                best_base = {\"run_id\": rid, \"value\": val}\n    gap = ((best_prop[\"value\"] - best_base[\"value\"]) / best_base[\"value\"] * 100) if best_base[\"value\"] != 0 else None\n    cmp_dir = results_dir / \"comparison\"\n    cmp_dir.mkdir(parents=True, exist_ok=True)\n    cmp_json_path = cmp_dir / \"aggregated_metrics.json\"\n    with open(cmp_json_path, \"w\") as f:\n        json.dump({\n            \"primary_metric\": \"Area-Under-Curve of \u2018retained-accuracy vs tasks\u2019 \u2191; secondary \u2013 CPU latency overhead \u2193\",\n            \"metrics\": aggregated,\n            \"best_proposed\": best_prop,\n            \"best_baseline\": best_base,\n            \"gap\": gap,\n        }, f, indent=2)\n\n    # ---------------- figures ----------------\n    bar_path = cmp_dir / \"comparison_retained_accuracy_auc_bar_chart.pdf\"\n    bar_chart(prim_map, \"Retained Accuracy AUC\", bar_path)\n\n    # t-test\n    if len(prim_map) \u003e= 2:\n        vals = list(prim_map.values())\n        t_stat, p_val = stats.ttest_ind(vals, vals)  # degenerate but placeholder\n        stats_path = cmp_dir / \"ttest.txt\"\n        with open(stats_path, \"w\") as f:\n            f.write(f\"t-stat: {t_stat}, p-val: {p_val}\\n\")\n    else:\n        stats_path = None\n\n    # print artefacts\n    print(\"Generated artefacts:\")\n    for p in per_run_artifacts + [cmp_json_path, bar_path, stats_path]:\n        if p is not None:\n            print(p)\n\n\nif __name__ == \"__main__\":\n    main()", "main_py": "import os\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nimport hydra\nfrom omegaconf import DictConfig, OmegaConf\n\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=None)\ndef main(cfg: DictConfig):\n    # ---------------- mode overrides ----------------\n    if cfg.mode == \"trial\":\n        cfg.wandb.mode = \"disabled\"\n        cfg.optuna.n_trials = 0\n        cfg.dataset.num_tasks = 2\n        cfg.training.task_epochs = 1\n    elif cfg.mode == \"full\":\n        cfg.wandb.mode = \"online\"\n    else:\n        raise ValueError(\"mode must be trial|full\")\n\n    # save resolved cfg\n    res_dir = Path(hydra.utils.to_absolute_path(cfg.results_dir))\n    res_dir.mkdir(parents=True, exist_ok=True)\n    cfg_path = res_dir / f\"{cfg.run}_resolved.yaml\"\n    OmegaConf.save(cfg, cfg_path)\n\n    # build command\n    cmd = [sys.executable, \"-u\", \"-m\", \"src.train\", f\"run={cfg.run}\", f\"mode={cfg.mode}\", f\"results_dir={cfg.results_dir}\"]\n    print(\"Executing:\", \" \".join(cmd))\n    env = os.environ.copy()\n    env.setdefault(\"HYDRA_FULL_ERROR\", \"1\")\n    subprocess.run(cmd, check=True, env=env)\n\n\nif __name__ == \"__main__\":\n    main()", "model_py": "\"\"\"Model architectures: HIMALAYA adapter + LILAC baseline with EWC\"\"\"\nimport math\nfrom typing import Tuple\n\nimport numpy as np\nimport torch\nfrom sklearn.neighbors import KDTree\nfrom torch import nn\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\n__all__ = [\"build_model\"]\n\n# -----------------------------------------------------------------------------\n# Quantisation helpers (3-bit \u0026 8-bit)\n# -----------------------------------------------------------------------------\n\n\ndef quantise_tensor(t: torch.Tensor, num_bits: int = 3) -\u003e Tuple[torch.Tensor, float, float]:\n    \"\"\"Uniform symmetric quantisation \u2013 returns int tensor + scale + zero.\"\"\"\n    q_levels = 2 ** num_bits - 1\n    maxv = t.abs().max().item()\n    scale = maxv / (q_levels / 2)\n    q = torch.clamp((t / scale).round(), -q_levels / 2, q_levels / 2).to(torch.int8)\n    return q, scale, 0.0  # zero-point is zero (symmetric)\n\n\ndef dequantise_tensor(q: torch.Tensor, scale: float):\n    return q.float() * scale\n\n\n# -----------------------------------------------------------------------------\n# Hyper-router H\u03b8 (~45k params)\n# -----------------------------------------------------------------------------\n\nclass HyperRouter(nn.Module):\n    def __init__(self, hidden_dim: int, total_atoms: int, hidden_params: int = 45000):\n        super().__init__()\n        # compute width so that parameter count \u2248 hidden_params\n        width = max(32, hidden_params // (hidden_dim + total_atoms))\n        self.net = nn.Sequential(\n            nn.Linear(hidden_dim, width),\n            nn.ReLU(),\n            nn.Linear(width, total_atoms),\n        )\n\n    def forward(self, x):  # x: (B, H)\n        return self.net(x)  # logits per atom\n\n\n# -----------------------------------------------------------------------------\n# HIMALAYA Adapter\n# -----------------------------------------------------------------------------\n\nclass HIMALAYAAdapter(nn.Module):\n    def __init__(self, hidden_dim: int, cfg):\n        super().__init__()\n        self.hidden_dim = hidden_dim\n        self.k_c = cfg.model.adapter.core_dictionary.num_atoms\n        self.k_e_max = cfg.model.adapter.elastic_dictionary.max_atoms\n        total_atoms = self.k_c + self.k_e_max\n        # Core dictionary trainable\n        self.D_c = nn.Parameter(torch.randn(self.k_c, hidden_dim) / math.sqrt(hidden_dim))\n        # Elastic dictionary initialised zeros \u0026 not part of grads until allocated\n        self.register_buffer(\"D_e\", torch.zeros(self.k_e_max, hidden_dim))\n        self.register_buffer(\"active\", torch.zeros(self.k_e_max, dtype=torch.bool))\n        self.register_buffer(\"usage\", torch.zeros(self.k_e_max, dtype=torch.long))\n        # Router\n        self.router = HyperRouter(hidden_dim, total_atoms, cfg.model.adapter.router.hidden_params)\n        self.expected_k = cfg.model.adapter.router.expected_active_atoms\n        temp = cfg.model.adapter.router.temperature_init\n        self.temperature = nn.Parameter(torch.tensor(float(temp)))\n        self.tau = cfg.training.similarity_threshold_tau\n        self.buffer: list[torch.Tensor] = []\n        self.buffer_size = 200\n        self.kdtree: KDTree | None = None\n\n    # ------------------------------------------------------------------\n    def _dict_mat(self) -\u003e torch.Tensor:\n        active_e = self.D_e[self.active]\n        return torch.cat([self.D_c, active_e], dim=0)  # (A, H)\n\n    def _update_kdtree(self):\n        with torch.no_grad():\n            mat = self._dict_mat().cpu().numpy().astype(np.float32)\n            if len(mat) \u003e 0:\n                self.kdtree = KDTree(mat)\n\n    def _grow_dict_if_needed(self):\n        if len(self.buffer) \u003c self.buffer_size:\n            return\n        residuals = torch.stack(self.buffer, dim=0)  # (N, H)\n        self.buffer.clear()\n        mat = self._dict_mat()  # (A, H)\n        if mat.size(0) == 0:\n            return\n        cos = torch.mm(nn.functional.normalize(residuals, dim=-1), nn.functional.normalize(mat, dim=-1).t())\n        if cos.mean().item() \u003c self.tau:\n            # promote mean residual\n            if (~self.active).any():\n                idx = (~self.active).nonzero(as_tuple=False)[0].item()\n                new_atom = residuals.mean(dim=0)\n                new_atom = nn.functional.normalize(new_atom, dim=-1)\n                self.D_e[idx].data.copy_(new_atom)\n                self.active[idx] = True\n                self.usage[idx] = 0\n                self._update_kdtree()\n            else:\n                # prune least used \u0026 replace\n                least = self.usage.argmax().item()\n                self._consolidate_into_core(self.D_e[least])\n                new_atom = residuals.mean(dim=0)\n                new_atom = nn.functional.normalize(new_atom, dim=-1)\n                self.D_e[least].data.copy_(new_atom)\n                self.usage[least] = 0\n                self._update_kdtree()\n\n    def _consolidate_into_core(self, atom: torch.Tensor):\n        # simple orthogonal projection onto core dictionary via SGD steps\n        with torch.no_grad():\n            proj = torch.mm(self.D_c, atom.unsqueeze(1)).squeeze(1)  # (k_c)\n            worst_idx = proj.argmin().item()\n            self.D_c.data[worst_idx] = atom  # overwrite (placeholder for Fisher projection)\n\n    # ------------------------------------------------------------------\n    def forward(self, hidden_states):  # hidden_states (B, T, H)\n        B, T, H = hidden_states.shape\n        cls = hidden_states[:, 0, :]\n        logits = self.router(cls) / self.temperature.abs()\n        probs = torch.softmax(logits, dim=-1)\n        topk = self.expected_k\n        topk_val, topk_idx = probs.topk(topk, dim=-1)\n        coeff = torch.zeros_like(probs)\n        coeff.scatter_(1, topk_idx, topk_val)\n        dict_mat = self._dict_mat()  # (A, H)\n        update_vec = coeff @ dict_mat  # (B, H)\n        # self-normalising: l2\u21921\n        update_vec = nn.functional.normalize(update_vec, dim=-1)\n        update_vec = update_vec / math.sqrt(H)\n        hidden_states = hidden_states + update_vec.unsqueeze(1)\n        # stats for growth\n        if self.training:\n            self.buffer.extend(update_vec.detach().cpu())\n            if len(self.buffer) \u003e= self.buffer_size:\n                self._grow_dict_if_needed()\n            # usage counts\n            for b in range(B):\n                for idx in topk_idx[b]:\n                    ridx = idx.item() - self.k_c\n                    if 0 \u003c= ridx \u003c self.k_e_max and self.active[ridx]:\n                        self.usage[ridx] += 1\n        return hidden_states\n\n    # ------------------------------------------------------------------\n    # Quantised inference \u2013 returns dict of quantised buffers\n    # ------------------------------------------------------------------\n    def export_quantised(self):\n        q_core, s_c, _ = quantise_tensor(self.D_c.detach(), 3)\n        q_e, s_e, _ = quantise_tensor(self.D_e[self.active].detach(), 3)\n        return {\"D_c\": (q_core, s_c), \"D_e\": (q_e, s_e)}\n\n\n# -----------------------------------------------------------------------------\n# LoRA wrapper for LILAC baseline\n# -----------------------------------------------------------------------------\n\nclass LoRALinear(nn.Module):\n    def __init__(self, linear: nn.Linear, r: int = 4, alpha: float = 1.0):\n        super().__init__()\n        self.linear = linear\n        self.r = r\n        self.alpha = alpha\n        self.A = nn.Parameter(torch.randn(r, linear.in_features) * 0.01)\n        self.B = nn.Parameter(torch.zeros(linear.out_features, r))\n        self.scale = alpha / r\n        self.linear.weight.requires_grad = False\n        if self.linear.bias is not None:\n            self.linear.bias.requires_grad = False\n\n    def forward(self, x):\n        return self.linear(x) + (x @ self.A.t() @ self.B.t()) * self.scale\n\n\ndef inject_lora(model: nn.Module, r: int = 4):\n    for name, module in model.named_modules():\n        if isinstance(module, nn.Linear):\n            parent = model\n            *path, leaf = name.split(\u0027.\u0027)\n            for p in path:\n                parent = getattr(parent, p)\n            setattr(parent, leaf, LoRALinear(getattr(parent, leaf), r=r, alpha=r))\n\n\n# -----------------------------------------------------------------------------\n# Builder \u2013 returns (model, tokenizer)\n# -----------------------------------------------------------------------------\n\ndef build_model(cfg) -\u003e Tuple[nn.Module, AutoTokenizer]:\n    backbone_name = cfg.model.backbone.name\n    tokenizer = AutoTokenizer.from_pretrained(backbone_name, cache_dir=\".cache/\", use_fast=True)\n    if tokenizer.pad_token_id is None:\n        tokenizer.pad_token = tokenizer.eos_token\n\n    model = AutoModelForCausalLM.from_pretrained(backbone_name, cache_dir=\".cache/\", torch_dtype=torch.float16)\n    model.gradient_checkpointing_enable() if cfg.training.gradient_checkpointing else None\n\n    # freeze backbone\n    for p in model.parameters():\n        p.requires_grad = False\n\n    hidden = model.config.hidden_size\n\n    adapter_type = cfg.model.adapter.type.upper()\n    if adapter_type == \"HIMALAYA\":\n        adapter = HIMALAYAAdapter(hidden, cfg)\n        # attach: modify model.forward\n        def _fwd(self, input_ids=None, attention_mask=None, labels=None, **kwargs):\n            outputs = super(model.__class__, self).forward(input_ids=input_ids,\n                                                          attention_mask=attention_mask,\n                                                          output_hidden_states=True,\n                                                          return_dict=True)\n            hidden_states = outputs.hidden_states[-1]\n            hidden_states = adapter(hidden_states)\n            logits = self.lm_head(hidden_states)\n            loss = None\n            if labels is not None:\n                loss_fct = nn.CrossEntropyLoss(ignore_index=-100)\n                loss = loss_fct(logits.view(-1, logits.size(-1)), labels.view(-1))\n            return {\"loss\": loss, \"logits\": logits}\n        model.forward = _fwd.__get__(model, model.__class__)\n        model.add_module(\"himalaya_adapter\", adapter)\n    elif adapter_type == \"LILAC\":\n        r = cfg.model.adapter.lora_rank\n        inject_lora(model, r=r)\n    else:\n        raise ValueError(adapter_type)\n\n    return model, tokenizer", "preprocess_py": "\"\"\"\nData pipeline building the 25-task continual stream described in the paper.  Each task yields a PyTorch\nDataLoader for training and validation splits.  Tokenisation is performed *once* on-the-fly with HuggingFace\nDatasets streaming to minimise disk footprint.\n\"\"\"\nfrom __future__ import annotations\n\nimport random\nfrom functools import partial\nfrom typing import Any, Dict, Iterable, List, Tuple\n\nfrom datasets import load_dataset\nfrom transformers import AutoTokenizer\n\nimport torch\nfrom torch.utils.data import DataLoader\n\n__all__ = [\"get_task_stream\"]\n\n# -----------------------------------------------------------------------------\n# Task registry \u2013 25 heterogeneous tasks (translation, summarisation, QA, code, classification)\n# -----------------------------------------------------------------------------\nTASKS: List[Dict[str, Any]] = [\n    # Translation (4)\n    {\"name\": \"wmt14_en_de\", \"hf\": (\"wmt14\", \"de-en\"), \"type\": \"translation\", \"src\": \"en\", \"tgt\": \"de\"},\n    {\"name\": \"opus_books_en_fr\", \"hf\": (\"opus_books\", \"en-fr\"), \"type\": \"translation\", \"src\": \"en\", \"tgt\": \"fr\"},\n    {\"name\": \"flores_en_sw\", \"hf\": (\"gsm8k\", None), \"type\": \"translation\", \"src\": \"en\", \"tgt\": \"sw\"},\n    {\"name\": \"iwslt17_en_de\", \"hf\": (\"iwslt2017\", \"iwslt2017-en-de\"), \"type\": \"translation\", \"src\": \"en\", \"tgt\": \"de\"},\n    # Summarisation (3)\n    {\"name\": \"cnn_dailymail\", \"hf\": (\"cnn_dailymail\", \"3.0.0\"), \"type\": \"summarisation\", \"doc\": \"article\", \"sum\": \"highlights\"},\n    {\"name\": \"xsum\", \"hf\": (\"xsum\", None), \"type\": \"summarisation\", \"doc\": \"document\", \"sum\": \"summary\"},\n    {\"name\": \"gigaword\", \"hf\": (\"gigaword\", None), \"type\": \"summarisation\", \"doc\": \"document\", \"sum\": \"summary\"},\n    # QA (3)\n    {\"name\": \"tydiqa_goldp\", \"hf\": (\"tydiqa\", \"goldp\"), \"type\": \"qa\", \"question\": \"question\", \"context\": \"context\", \"answers\": \"answers\"},\n    {\"name\": \"squad_v2\", \"hf\": (\"squad_v2\", None), \"type\": \"qa\", \"question\": \"question\", \"context\": \"context\", \"answers\": \"answers\"},\n    {\"name\": \"wiki_qa\", \"hf\": (\"wiki_qa\", None), \"type\": \"qa\", \"question\": \"question\", \"context\": \"sentence\", \"answers\": \"answer\"},\n    # Code (2)\n    {\"name\": \"code_alpaca\", \"hf\": (\"code_alpaca\", None), \"type\": \"code\", \"prompt\": \"instruction\", \"solution\": \"output\"},\n    {\"name\": \"mbpp\", \"hf\": (\"mbpp\", None), \"type\": \"code\", \"prompt\": \"text\", \"solution\": \"code\"},\n    # Classification (13)\n    {\"name\": \"glue_rte\", \"hf\": (\"glue\", \"rte\"), \"type\": \"classification\", \"text\": \"sentence\", \"label\": \"label\"},\n    {\"name\": \"boolq\", \"hf\": (\"super_glue\", \"boolq\"), \"type\": \"classification\", \"text\": \"passage\", \"label\": \"label\"},\n    {\"name\": \"ag_news\", \"hf\": (\"ag_news\", None), \"type\": \"classification\", \"text\": \"text\", \"label\": \"label\"},\n    {\"name\": \"dbpedia\", \"hf\": (\"dbpedia_14\", None), \"type\": \"classification\", \"text\": \"content\", \"label\": \"label\"},\n    {\"name\": \"trec\", \"hf\": (\"trec\", None), \"type\": \"classification\", \"text\": \"text\", \"label\": \"label\"},\n    {\"name\": \"sst2\", \"hf\": (\"glue\", \"sst2\"), \"type\": \"classification\", \"text\": \"sentence\", \"label\": \"label\"},\n    {\"name\": \"imdb\", \"hf\": (\"imdb\", None), \"type\": \"classification\", \"text\": \"text\", \"label\": \"label\"},\n    {\"name\": \"mnli\", \"hf\": (\"glue\", \"mnli\"), \"type\": \"classification\", \"text\": \"premise\", \"label\": \"label\"},\n    {\"name\": \"conll2003\", \"hf\": (\"conll2003\", None), \"type\": \"classification\", \"text\": \"tokens\", \"label\": \"ner_tags\"},\n    {\"name\": \"xnli_en\", \"hf\": (\"xnli\", None), \"type\": \"classification\", \"text\": \"premise\", \"label\": \"label\"},\n    {\"name\": \"yelp_polarity\", \"hf\": (\"yelp_polarity\", None), \"type\": \"classification\", \"text\": \"text\", \"label\": \"label\"},\n    {\"name\": \"mrpc\", \"hf\": (\"glue\", \"mrpc\"), \"type\": \"classification\", \"text\": \"sentence1\", \"label\": \"label\"},\n    {\"name\": \"qqp\", \"hf\": (\"glue\", \"qqp\"), \"type\": \"classification\", \"text\": \"question1\", \"label\": \"label\"},\n]\n\n# -----------------------------------------------------------------------------\n# Prompt builders\n# -----------------------------------------------------------------------------\n\ndef build_translation(example, src: str, tgt: str):\n    prompt = f\"Translate {src} to {tgt}: {example[src]}\\nTARGET:\"  # model must output target\n    label = example[tgt]\n    return prompt, label\n\ndef build_summarisation(example, doc: str, sum: str):\n    prompt = f\"Summarise: {example[doc]}\\nSUMMARY:\"\n    return prompt, example[sum]\n\ndef build_qa(example, question: str, context: str, answers: str):\n    ans_list = example[answers][\"text\"] if isinstance(example[answers], dict) else example[answers]\n    ans = ans_list[0] if len(ans_list) else \"unknown\"\n    prompt = f\"Context: {example[context]}\\nQuestion: {example[question]}\\nAnswer:\"\n    return prompt, ans\n\ndef build_code(example, prompt: str, solution: str):\n    return f\"### Instruction:\\n{example[prompt]}\\n### Solution:\\n\", example[solution]\n\ndef build_classification(example, text: str, label: str):\n    return f\"Classify: {example[text]}\\nLABEL:\", str(example[label])\n\n\n# -----------------------------------------------------------------------------\n# Collate function\n# -----------------------------------------------------------------------------\n\ndef collate_fn_builder(tokenizer: AutoTokenizer):\n    pad_id = tokenizer.pad_token_id or tokenizer.eos_token_id\n\n    def _fn(batch):\n        input_ids = [torch.tensor(b[\"input_ids\"], dtype=torch.long) for b in batch]\n        labels = [torch.tensor(b[\"labels\"], dtype=torch.long) for b in batch]\n        attn = [torch.tensor(b[\"attention_mask\"], dtype=torch.long) for b in batch]\n        input_ids = torch.nn.utils.rnn.pad_sequence(input_ids, batch_first=True, padding_value=pad_id)\n        attn = torch.nn.utils.rnn.pad_sequence(attn, batch_first=True, padding_value=0)\n        labels = torch.nn.utils.rnn.pad_sequence(labels, batch_first=True, padding_value=-100)\n        return {\"input_ids\": input_ids, \"attention_mask\": attn, \"labels\": labels}\n\n    return _fn\n\n\n# -----------------------------------------------------------------------------\n# Main public API\n# -----------------------------------------------------------------------------\n\ndef get_task_stream(cfg, tokenizer: AutoTokenizer):\n    random.seed(0)\n    selected = TASKS[: cfg.dataset.num_tasks]\n    max_len = cfg.dataset.max_seq_length\n    batch_size = cfg.training.batch_size\n\n    for task in selected:\n        ds = load_dataset(*task[\"hf\"], cache_dir=\".cache/\", streaming=cfg.dataset.streaming)\n        train_split = \"train\" if \"train\" in ds else list(ds.keys())[0]\n        val_split = \"validation\" if \"validation\" in ds else \"test\" if \"test\" in ds else train_split\n        ds_train, ds_val = ds[train_split], ds[val_split]\n\n        ttype = task[\"type\"]\n        if ttype == \"translation\":\n            builder = partial(build_translation, src=task[\"src\"], tgt=task[\"tgt\"])\n        elif ttype == \"summarisation\":\n            builder = partial(build_summarisation, doc=task[\"doc\"], sum=task[\"sum\"])\n        elif ttype == \"qa\":\n            builder = partial(build_qa, question=task[\"question\"], context=task[\"context\"], answers=task[\"answers\"])\n        elif ttype == \"code\":\n            builder = partial(build_code, prompt=task[\"prompt\"], solution=task[\"solution\"])\n        elif ttype == \"classification\":\n            builder = partial(build_classification, text=task[\"text\"], label=task[\"label\"])\n        else:\n            raise ValueError(ttype)\n\n        def _tok(ex):\n            prompt, tgt = builder(ex)\n            enc = tokenizer(prompt, truncation=True, max_length=max_len)\n            tgt_enc = tokenizer(tgt, truncation=True, max_length=max_len)\n            input_ids = enc[\"input_ids\"] + tgt_enc[\"input_ids\"]\n            labels = [-100] * len(enc[\"input_ids\"]) + tgt_enc[\"input_ids\"]\n            return {\"input_ids\": input_ids, \"attention_mask\": [1] * len(input_ids), \"labels\": labels}\n\n        ds_train = ds_train.map(_tok)\n        ds_val = ds_val.map(_tok)\n        collate = collate_fn_builder(tokenizer)\n        train_loader = DataLoader(ds_train, batch_size=batch_size, shuffle=not cfg.dataset.streaming, collate_fn=collate)\n        val_loader = DataLoader(ds_val, batch_size=cfg.evaluation.eval_batch_size, shuffle=False, collate_fn=collate)\n        yield task[\"name\"], train_loader, val_loader", "pyproject_toml": "[project]\nname = \"himalaya_experiments\"\nversion = \"0.1.0\"\ndescription = \"Hydra-managed experiments for HIMALAYA continual-learning adapter\"\nrequires-python = \"\u003e=3.9\"\nlicense = {text = \"MIT\"}\n\n[project.dependencies]\ntorch = \"\u003e=2.1\"\ntransformers = \"\u003e=4.34\"\ndatasets = \"\u003e=2.14\"\nhydra-core = \"\u003e=1.3\"\nwandb = \"\u003e=0.15\"\noptuna = \"\u003e=3.5\"\nmatplotlib = \"\u003e=3.7\"\nseaborn = \"\u003e=0.13\"\npandas = \"\u003e=2.1\"\nnumpy = \"\u003e=1.23\"\nscikit-learn = \"\u003e=1.3\"\nscipy = \"\u003e=1.11\"\ntqdm = \"\u003e=4.66\"\n", "train_py": "import json\nimport math\nimport os\nimport random\nimport time\nfrom pathlib import Path\nfrom typing import Dict, List, Tuple\n\nimport hydra\nimport numpy as np\nimport optuna\nimport torch\nimport torch.nn.functional as F\nfrom omegaconf import DictConfig, OmegaConf\nfrom sklearn.metrics import confusion_matrix\nfrom torch import nn, optim\nfrom torch.cuda.amp import GradScaler, autocast\nfrom torch.utils.data import DataLoader\nfrom tqdm import tqdm\nfrom transformers import get_linear_schedule_with_warmup\n\nfrom .model import build_model\nfrom .preprocess import get_task_stream\n\n# -----------------------------------------------------------------------------\n# Utilities\n# -----------------------------------------------------------------------------\n\n\ndef set_seed(seed: int = 42):\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = False\n    torch.backends.cudnn.benchmark = True\n\n\ndef _move_to_device(batch: Dict[str, torch.Tensor], device: torch.device):\n    return {k: v.to(device) for k, v in batch.items() if torch.is_tensor(v)}\n\n\n# -----------------------------------------------------------------------------\n# Fisher consolidation helper (used by HIMALAYA + LILAC-EWC)\n# -----------------------------------------------------------------------------\n\n\ndef compute_fisher(model: nn.Module, dataloader: DataLoader, device: torch.device, samples: int = 128) -\u003e Dict[str, torch.Tensor]:\n    \"\"\"Return per-parameter diag Fisher (empirical).\"\"\"\n    fisher: Dict[str, torch.Tensor] = {n: torch.zeros_like(p, dtype=torch.float32) for n, p in model.named_parameters() if p.requires_grad}\n    model.eval()\n    cnt = 0\n    with torch.no_grad():\n        for batch in dataloader:\n            batch = _move_to_device(batch, device)\n            outputs = model(**batch)\n            loss = outputs[\"loss\"]\n            grads = torch.autograd.grad(loss, [p for p in model.parameters() if p.requires_grad], retain_graph=False)\n            for (name, _), g in zip([(n, p) for n, p in model.named_parameters() if p.requires_grad], grads):\n                fisher[name] += g.detach() ** 2\n            cnt += 1\n            if cnt \u003e= samples:\n                break\n    for name in fisher:\n        fisher[name] /= max(cnt, 1)\n    return fisher\n\n\n# -----------------------------------------------------------------------------\n# Validation / metrics helpers\n# -----------------------------------------------------------------------------\n\n\ndef evaluate_stream(model: nn.Module, loaders: List[Tuple[str, DataLoader]], device: torch.device, cfg: DictConfig, global_step: int):\n    \"\"\"Evaluate on each task seen so far; returns retained accuracy and per-task losses.\"\"\"\n    model.eval()\n    retained_scores = []\n    per_task_loss = {}\n    conf_mats = {}\n    with torch.no_grad():\n        for task_name, dl in loaders:\n            total_tok, total_loss = 0, 0.0\n            preds_all, labels_all = [], []\n            pbar = enumerate(dl)\n            for step, batch in pbar:\n                if cfg.mode == \"trial\" and step \u003e 1:\n                    break\n                batch = _move_to_device(batch, device)\n                outputs = model(**batch)\n                loss = outputs[\"loss\"].detach()\n                total_loss += loss.item() * batch[\"input_ids\"].numel()\n                total_tok += batch[\"input_ids\"].numel()\n                # --- classification confusion matrix collection (if small vocab label) ---\n                if batch[\"labels\"].ndim == 2 and batch[\"labels\"].size(1) == 1:  # heuristic\n                    logits = outputs[\"logits\"]\n                    pred = logits.argmax(dim=-1).view(-1).cpu().tolist()\n                    lab = batch[\"labels\"].view(-1).cpu().tolist()\n                    preds_all.extend(pred)\n                    labels_all.extend(lab)\n            mean_loss = total_loss / max(total_tok, 1)\n            perf = 1.0 / (1.0 + mean_loss)\n            retained_scores.append(perf)\n            per_task_loss[task_name] = mean_loss\n            if preds_all:\n                cm = confusion_matrix(labels_all, preds_all)\n                conf_mats[task_name] = cm.tolist()\n    retained_acc = float(sum(retained_scores) / max(len(retained_scores), 1))\n    metrics = {\"val_retained_accuracy\": retained_acc, **{f\"val_loss_{k}\": v for k, v in per_task_loss.items()}}\n    return metrics, conf_mats\n\n\n# -----------------------------------------------------------------------------\n# Latency measurement (CPU, post-training)\n# -----------------------------------------------------------------------------\n\n\ndef measure_cpu_latency(model: nn.Module, tokenizer, seq_len: int = 64, trials: int = 25):\n    model_cpu = model.to(\"cpu\").eval()\n    dummy = torch.randint(0, tokenizer.vocab_size, (1, seq_len), dtype=torch.long)\n    with torch.no_grad():\n        # warm-up\n        for _ in range(5):\n            model_cpu(input_ids=dummy, attention_mask=torch.ones_like(dummy))\n        start = time.time()\n        for _ in range(trials):\n            model_cpu(input_ids=dummy, attention_mask=torch.ones_like(dummy))\n        end = time.time()\n    return (end - start) / trials * 1000.0  # ms\n\n\n# -----------------------------------------------------------------------------\n# Main training routine for one full stream (optionally called inside Optuna)\n# -----------------------------------------------------------------------------\n\n\ndef train_full_stream(cfg: DictConfig, trial: optuna.trial.Trial = None):\n    import wandb  # local import so that WANDB_MODE works\n\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    results_dir = Path(hydra.utils.to_absolute_path(cfg.results_dir))\n    results_dir.mkdir(parents=True, exist_ok=True)\n\n    # ---------------------------- WandB setup ---------------------------\n    if cfg.wandb.mode != \"disabled\":\n        os.environ[\"WANDB_MODE\"] = cfg.wandb.mode\n        wandb.init(entity=cfg.wandb.entity,\n                   project=cfg.wandb.project,\n                   id=cfg.run.run_id if trial is None else None,\n                   resume=\"allow\" if trial is None else None,\n                   config=OmegaConf.to_container(cfg, resolve=True))\n        print(\"WandB URL:\", wandb.run.url)\n    else:\n        wandb.init(mode=\"disabled\")\n\n    # -------------------- build model \u0026 data pipeline -------------------\n    model, tokenizer = build_model(cfg)\n    model.to(device)\n    task_stream = list(get_task_stream(cfg, tokenizer))  # list so we can reuse for fisher / EWC\n\n    # --------------------- optimiser / scheduler -----------------------\n    trainable_params = [p for p in model.parameters() if p.requires_grad]\n    optimizer = optim.AdamW(trainable_params, lr=cfg.training.learning_rate, weight_decay=cfg.training.weight_decay)\n    scaler = GradScaler(enabled=cfg.training.mixed_precision and torch.cuda.is_available())\n\n    # Place-holder scheduler: updated per task\n    scheduler = None\n\n    # ------------------------ EWC buffers ------------------------------\n    fisher_prev: Dict[str, torch.Tensor] = {}\n    opt_prev: Dict[str, torch.Tensor] = {}\n\n    global_step = 0\n    retained_history = []\n\n    for task_idx, (task_name, train_dl, val_dl) in enumerate(task_stream):\n        print(f\"\\n=== Task {task_idx + 1}/{cfg.dataset.num_tasks}: {task_name} ===\")\n\n        # rebuild scheduler for current task\n        t_total = len(train_dl) * cfg.training.task_epochs\n        scheduler = get_linear_schedule_with_warmup(optimizer,\n                                                    num_warmup_steps=min(cfg.training.warmup_steps, max(t_total // 10, 1)),\n                                                    num_training_steps=t_total)\n        for epoch in range(cfg.training.task_epochs):\n            pbar = tqdm(enumerate(train_dl), total=len(train_dl), desc=f\"{task_name} e{epoch}\")\n            model.train()\n            for step, batch in pbar:\n                if cfg.mode == \"trial\" and step \u003e 1:\n                    break\n                batch = _move_to_device(batch, device)\n                optimizer.zero_grad(set_to_none=True)\n                with autocast(enabled=cfg.training.mixed_precision and torch.cuda.is_available()):\n                    outputs = model(**batch)\n                    loss = outputs[\"loss\"]\n                    # ---- EWC regulariser (LILAC baseline only) ----\n                    if cfg.model.adapter.type.upper() == \"LILAC\" and fisher_prev:\n                        ewc_loss = 0.0\n                        for name, p in model.named_parameters():\n                            if p.requires_grad and name in fisher_prev:\n                                ewc_loss += (fisher_prev[name] * (p - opt_prev[name]).pow(2)).sum()\n                        loss = loss + cfg.model.adapter.get(\"ewc_lambda\", 0.0) * ewc_loss\n                scaler.scale(loss).backward()\n                scaler.step(optimizer)\n                scaler.update()\n                scheduler.step()\n                global_step += 1\n                if wandb.run is not None:\n                    wandb.log({\"train_loss\": loss.item(), \"global_step\": global_step, \"task\": task_idx + 1})\n            # epoch end\n        # -------------------- evaluation after task --------------------\n        metrics, conf_mats = evaluate_stream(model, [(task_name, val_dl)], device, cfg, global_step)\n        retained_history.append(metrics[\"val_retained_accuracy\"])\n        if wandb.run is not None:\n            wandb.log({**metrics, \"task\": task_idx + 1, \"global_step\": global_step})\n            for t_name, cm in conf_mats.items():\n                wandb.summary[f\"confusion_matrix_{t_name}\"] = cm\n\n        # -------------- Fisher consolidation for next task -------------\n        if cfg.model.adapter.type.upper() == \"LILAC\":\n            fisher_prev = compute_fisher(model, val_dl, device)\n            opt_prev = {n: p.detach().clone() for n, p in model.named_parameters() if p.requires_grad}\n\n    # -------------------------- final metrics ---------------------------\n    auc = 0.0\n    for i in range(1, len(retained_history)):\n        auc += 0.5 * (retained_history[i] + retained_history[i - 1])\n    cpu_latency_ms = measure_cpu_latency(model, tokenizer) if cfg.evaluation.cpu_latency_device == \"raspberry-pi-4\" else 0.0\n    if wandb.run is not None:\n        wandb.summary[\"retained_accuracy_auc\"] = auc\n        wandb.summary[\"cpu_latency_overhead_ms\"] = cpu_latency_ms\n        wandb.finish()\n    # ----------------- Optuna reporting (if inside trial) --------------\n    if trial is not None:\n        trial.set_user_attr(\"auc\", auc)\n        trial.report(auc, step=0)\n        return auc\n    return auc\n\n\n# -----------------------------------------------------------------------------\n# Optuna hyper-parameter search\n# -----------------------------------------------------------------------------\n\n\ndef launch_optuna(cfg: DictConfig):\n    def _objective(trial: optuna.Trial):\n        # sample search-space\n        for hp, spec in cfg.optuna.search_space.items():\n            if spec[\"type\"] == \"loguniform\":\n                cfg.training[hp] = trial.suggest_float(hp, spec[\"low\"], spec[\"high\"], log=True)\n            elif spec[\"type\"] == \"uniform\":\n                cfg.training[hp] = trial.suggest_float(hp, spec[\"low\"], spec[\"high\"])       \n            elif spec[\"type\"] == \"categorical\":\n                cfg.model.adapter[hp] = trial.suggest_categorical(hp, spec[\"choices\"])\n            else:\n                raise ValueError(f\"Unknown search type {spec[\u0027type\u0027]}\")\n        # shorten stream for quick objective: first 3 tasks only\n        orig_num_tasks = cfg.dataset.num_tasks\n        cfg.dataset.num_tasks = min(3, orig_num_tasks)\n        score = train_full_stream(cfg, trial)\n        cfg.dataset.num_tasks = orig_num_tasks\n        return score\n\n    study = optuna.create_study(direction=\"maximize\")\n    study.optimize(_objective, n_trials=cfg.optuna.n_trials)\n    return study.best_params\n\n\n# -----------------------------------------------------------------------------\n# Hydra entry-point\n# -----------------------------------------------------------------------------\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=None)\ndef main(cfg: DictConfig):\n    # ------------------ Mode-specific overrides -----------------------\n    if cfg.mode == \"trial\":\n        cfg.wandb.mode = \"disabled\"\n        cfg.optuna.n_trials = 0\n        cfg.dataset.num_tasks = 2\n        cfg.training.task_epochs = 1\n    elif cfg.mode == \"full\":\n        cfg.wandb.mode = \"online\"\n    else:\n        raise ValueError(\"mode must be \u0027trial\u0027 or \u0027full\u0027\")\n\n    set_seed()\n\n    # --------------------- Optuna (if requested) ----------------------\n    if cfg.optuna.n_trials \u003e 0:\n        best_params = launch_optuna(cfg)\n        print(\"Optuna best params:\", best_params)\n        # apply to cfg\n        for k, v in best_params.items():\n            if k in cfg.training:\n                cfg.training[k] = v\n            elif k in cfg.model.adapter:\n                cfg.model.adapter[k] = v\n\n    # -------------------- Final full training ------------------------\n    _ = train_full_stream(cfg)\n\n\nif __name__ == \"__main__\":\n    main()"}



Analyze the experiment code thoroughly. Ensure it is complete, executable, and ready for publication-quality research experiments.
Output:
{
    "is_code_ready": false,
    "code_issue": "The experiment code cannot run as-is.\nKey blocking problems:\n1. Package import structure – src/train.py uses relative imports (\"from .model import …\") but no src/__init__.py is allowed, so Python cannot resolve these modules.\n2. HIMALAYA adapter patching – build_model replaces AutoModelForCausalLM.forward with a new _fwd that calls super(model.__class__, self).forward().  After the monkey-patch this call resolves to PreTrainedModel.forward (abstract) → runtime error.  The original forward should be preserved and invoked, or the adapter should be inserted via hooks instead of overwriting.\n3. compute_fisher() is wrapped in torch.no_grad() yet calls torch.autograd.grad(), which requires gradients; this raises a RuntimeError during training.\n4. Optuna trials are still logged to WandB (wandb.init called inside train_full_stream when trial is not None), violating the “no intermediate trials to WandB” rule.\n5. Dataset registry contains obvious typos (e.g. flores_en_sw points to \"gsm8k\"), and streaming datasets fed to torch.utils.data.DataLoader with shuffle/len operations will crash because IterableDataset lacks __len__.\n6. evaluate.py’s t-test placeholder uses identical arrays (stats.ttest_ind(vals, vals)) – results are meaningless and violates the spec requiring proper significance tests.\n7. Several minor but blocking issues: KDTree import without handling empty dict, missing CPU latency overhead direction handling in gap calculation, improper task detection for confusion matrices, etc.\n\nBecause of these issues the code is not executable nor production-ready and violates Hydra/WandB/Optuna requirements."
}
