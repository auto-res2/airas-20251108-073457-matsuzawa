
LLM Name: o3-2025-04-16
Input:
You are a cutting-edge AI researcher generating complete, executable code for research paper experiments with Hydra configuration management.

Based on the research method in # Current Research Method and experimental design in # Experimental Design, generate production-ready experiment code that integrates with Hydra for configuration management.

# Instructions: Complete Experiment Code Generation

## Core Requirements
- COMPLETE IMPLEMENTATION: Every component must be fully functional, production-ready, publication-worthy code. No "omitted for brevity", no "simplified version", no TODO, PLACEHOLDER, pass, or ...
- PYTORCH EXCLUSIVELY: Use PyTorch as the deep learning framework
- HYDRA INTEGRATION: Use Hydra to manage all experiment configurations from `config/runs/*.yaml` files. Use `config_path="../config"` in all @hydra.main decorators
- COMPLETE DATA PIPELINE: Full data loading and preprocessing implementation. Use `.cache/` as the cache directory for all datasets and models (e.g., for HuggingFace, set `cache_dir=".cache/"`)
- WANDB REQUIRED: WandB is mandatory for metrics logging (except trial_mode validation)

## Hydra Configuration Structure
Each run config file (`config/runs/{run_id}.yaml`) contains:
- run_id: Unique identifier for this run
- method: The method name (baseline, proposed, ablation, etc.)
- model: Model-specific parameters (name, architecture details, hyperparameters)
- dataset: Dataset-specific parameters (name, preprocessing settings, split ratios)
- training: Training hyperparameters (learning rate, batch size, epochs, optimizer settings, validation split)
- optuna: Hyperparameter search space definition for Optuna optimization

## Command Line Interface
The generated code must support the following CLI:

**Training (main.py):**
```bash
# Full experiment with WandB logging
uv run python -u -m src.main run={run_id} results_dir={path} mode=full

# Trial mode (validation only, WandB disabled)
uv run python -u -m src.main run={run_id} results_dir={path} mode=trial
```
- `run`: Experiment run_id (matching a run_id from config/runs/*.yaml)
- `results_dir`: Output directory (passed from GitHub Actions workflow)
- `mode`: Execution mode (required parameter)
  * `mode=trial`: Lightweight execution for validation (epochs=1, batches limited to 1-2, wandb.mode=disabled, optuna.n_trials=0)
  * `mode=full`: Full experiment execution (wandb.mode=online, full epochs, full Optuna trials)
  * **Code must automatically configure based on mode (e.g., `if cfg.mode == "trial": cfg.wandb.mode = "disabled"; cfg.optuna.n_trials = 0` elif `cfg.mode == "full": cfg.wandb.mode = "online"`)**

**Evaluation (evaluate.py, independent execution):**
```bash
uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2", ...]'
```
- `results_dir`: Directory containing experiment metadata and where outputs will be saved
- `run_ids`: JSON string list of run IDs to evaluate (e.g., '["run-1-proposed-bert-glue", "run-2-baseline-bert-glue"]')
- Executed as a separate workflow after all training runs complete
- **NOT called from main.py**

## Script Structure (ExperimentCode format)
Generate complete code for these files ONLY. Do not create any additional files beyond this structure:

**`src/train.py`**: Single experiment run executor
- Uses Hydra config to load all parameters
- Called as subprocess by main.py
- Responsibilities:
  * Train model with given configuration
  * Initialize WandB: `wandb.init(entity=cfg.wandb.entity, project=cfg.wandb.project, id=cfg.run.run_id, config=OmegaConf.to_container(cfg, resolve=True), resume="allow")`
  * Skip `wandb.init()` if `cfg.wandb.mode == "disabled"` (trial_mode)
  * **Optuna Integration**: If using Optuna for hyperparameter search, DO NOT log intermediate trial results to WandB - only train once with the best hyperparameters after optimization completes and log that final run
  * **Log ALL metrics to WandB comprehensively**:
    - Use `wandb.log()` at each training step/batch/epoch with ALL relevant metrics
    - Log as frequently as possible (per-batch or per-epoch) to capture training dynamics
    - Use CONSISTENT metric names across train.py and evaluate.py (e.g., if train.py logs "train_acc", evaluate.py MUST use run.history(keys=["train_acc",...]))
  * **Save final/best metrics to WandB summary**:
    - Use `wandb.summary["key"] = value` for final results
  * Print WandB run URL to stdout
- **NO results.json, no stdout JSON output, no figure generation**

**`src/evaluate.py`**: Independent evaluation and visualization script
- **Execution**: Run independently via `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2"]'`
- **NOT called from main.py** - executes as separate workflow after all training completes
- **Responsibilities**:
  * Parse command line arguments:
    - `results_dir`: Output directory path
    - `run_ids`: JSON string list of run IDs (parse with `json.loads(args.run_ids)`)
  * Load WandB config from `config/config.yaml` (in repository root)
  * **Retrieve comprehensive experimental data from WandB API** for specified run_ids:
    ```python
    import json
    api = wandb.Api()
    run_ids = json.loads(args.run_ids)  # Parse JSON string to list
    for run_id in run_ids:
        run = api.run(f"{entity}/{project}/{run_id}")
        history = run.history()  # pandas DataFrame with ALL time-series metrics (train_loss, val_acc, etc.)
        summary = run.summary._json_dict  # Final/best metrics (best_val_acc, final_test_acc, etc.)
        config = dict(run.config)  # Run configuration (hyperparameters, model settings, etc.)
    ```
  * **STEP 1: Per-Run Processing** (for each run_id):
    - Export **comprehensive** run-specific metrics to: `{results_dir}/{run_id}/metrics.json`
    - Generate run-specific figures (learning curves, confusion matrices) to: `{results_dir}/{run_id}/`
    - Each run should have its own subdirectory with its metrics and figures
  * **STEP 2: Aggregated Analysis** (after processing all runs):
    - Export aggregated metrics to: `{results_dir}/comparison/aggregated_metrics.json` with the following structure:
      ```json
      {
        "primary_metric": "Area-Under-Curve of ‘retained-accuracy vs tasks’ ↑; secondary – CPU latency overhead ↓",
        "metrics": {
          "metric_name_1": {"run_id_1": value1, "run_id_2": value2, ...},
          "metric_name_2": {"run_id_1": value1, "run_id_2": value2, ...}
        },
        "best_proposed": {
          "run_id": "proposed-iter2-model-dataset",
          "value": 0.92
        },
        "best_baseline": {
          "run_id": "comparative-1-model-dataset",
          "value": 0.88
        },
        "gap": 4.55
      }
      ```
      The structure includes:
      - "primary_metric": The primary evaluation metric name from the hypothesis (Area-Under-Curve of ‘retained-accuracy vs tasks’ ↑; secondary – CPU latency overhead ↓)
      - "metrics": All collected metrics organized by metric name, then by run_id
      - "best_proposed": The run_id and value of the proposed method with the best primary_metric performance (run_id contains "proposed")
      - "best_baseline": The run_id and value of the baseline/comparative method with the best primary_metric performance (run_id contains "comparative" or "baseline")
      - "gap": Performance gap calculated as: (best_proposed.value - best_baseline.value) / best_baseline.value * 100
        * Use the expected results from the hypothesis (1) After 25 tasks HIMALAYA keeps ≤1.5 pp average forgetting vs 5–8 pp (LoRA) and 2.7 pp (LILAC/COLTAS).
2) Final mean performance 1-3 pp above LILAC on classification, +0.6 BLEU on WMT EN→DE, +1.4 ROUGE-L summarisation.
3) Extra storage fixed at 2.3 MB, peak Pi-4 latency +7 % (others +20 % or cannot run due to memory).
4) Atom norm remains bounded ≤1.05 for entire stream, confirming theoretical guarantee.) to determine metric direction
        * If the metric should be minimized (like "loss", "perplexity", "error"), reverse the sign of the gap
        * The gap represents the percentage improvement of the proposed method over the best baseline
    - Generate comparison figures to: `{results_dir}/comparison/`:
      * Cross-run comparison charts (bar charts, box plots)
      * Performance metrics tables
      * Statistical significance tests
  * **Figure Generation Guidelines**:
    - Use matplotlib or seaborn with proper legends, annotations, tight_layout
    - For line graphs: annotate significant values (final/best values)
    - For bar graphs: annotate values above each bar
    - Use GLOBALLY UNIQUE image filenames to prevent collisions across different runs and directories**:
      * Per-run figures: `{run_id}_{figure_topic}[_<condition>][_pairN].pdf` (e.g., `run-1-proposed-bert-glue_learning_curve.pdf`)
      * Comparison figures: `comparison_{figure_topic}[_<condition>][_pairN].pdf` (e.g., `comparison_accuracy_bar_chart.pdf`)
  * Print all generated file paths to stdout (both per-run and comparison)

**`src/preprocess.py`**: Complete preprocessing pipeline implementation for the specified datasets

**`src/model.py`**: Complete model architecture implementations for all methods (proposed and comparative methods)

**`src/main.py`**: Main orchestrator
- Receives run_id via Hydra, launches train.py as subprocess, manages logs
- **DOES NOT call evaluate.py** (evaluate.py runs independently in separate workflow)
- Use `@hydra.main(config_path="../config")` since execution is from repository root
- **Mode handling**: Automatically configure based on `cfg.mode`:
  * When `cfg.mode == "trial"`: Set `cfg.wandb.mode = "disabled"`, `cfg.optuna.n_trials = 0`, epochs=1, etc.
  * When `cfg.mode == "full"`: Set `cfg.wandb.mode = "online"` and use full configuration

**`config/config.yaml`**: Main Hydra configuration file
- MUST include WandB configuration:
  ```yaml
  wandb:
    entity: gengaru617-personal
    project: 2025-1108-1
    mode: online  # Automatically set to "disabled" in trial_mode
  ```
- `WANDB_API_KEY` environment variable is automatically available for authentication

**`pyproject.toml`**: Complete project dependencies
- MUST include: `hydra-core`, `wandb` (required)
- Include as needed: `optuna`, `torch`, `transformers`, `datasets`, etc.


## Key Implementation Focus Areas
1. **Hydra-Driven Configuration**: All parameters loaded from run configs dynamically
2. **Algorithm Core**: Full implementation of the proposed method with proper abstraction
3. **Mode-Based Behavior**: Code must automatically configure based on `cfg.mode` ("trial" vs "full")
   - `mode=trial`: Set `cfg.wandb.mode="disabled"`, `cfg.optuna.n_trials=0`, epochs=1, limited batches
   - `mode=full`: Set `cfg.wandb.mode="online"`, use full configuration
4. **Run Execution**: main.py executes a single run_id passed via CLI (GitHub Actions dispatches multiple runs separately)
5. **WandB Integration**: All metrics logged to WandB; train.py does NOT output JSON to stdout or save results.json
6. **Independent Evaluation**: evaluate.py runs separately, fetches data from WandB API, generates all figures



## Code Validation Feedback


**Previous Validation Issue**: Code does not satisfy several core criteria:
1. Hydra-to-WandB linkage is broken – train.py tries to obtain the ID via `getattr(cfg, "run", {}).get(...)`, but `cfg.run` is a *string* (the name of the config file), therefore `.get` raises AttributeError; the run_id resolves to "noid", so WandB logging and later evaluation will fail.
2. Classification preprocessing is wrong – `build_classification` converts integer labels to `str`, so later `torch.tensor([...], dtype=torch.long)` crashes. Even if cast succeeded, the logits→cross-entropy path expects int class indices, not strings.
3. HIMALAYA algorithm is only partially implemented: it merely adds an "update_vec" to the hidden states; the advertised outer-product weight update, analytical norm rescaling, KD-Tree-based routing and Fisher consolidation are missing. Therefore requirement “complete model architectures, no placeholders / simplified versions” is violated.
4. Dataset stream hard-codes only 5 demo tasks; the 25-task continual stream described in the run configs cannot be produced, violating the “complete data pipeline” criterion.
5. Optuna/WandB separation: train.py still calls `wandb.log()` even when `wandb.init(mode="disabled")`; although WandB ignores the data, this formally violates the rule “DO NOT log intermediate trial results to WandB” during Optuna sweeps.

Because of these issues the code is not directly executable nor publication-ready.
**Action Required**: Address this issue in the implementation.

**Previous Code (for reference)**:
{"config_yaml": "defaults:\n  - _self_\n  - runs: ${run}\n\n# CLI overrides\nrun: null\nresults_dir: outputs\nmode: full\n\nwandb:\n  entity: gengaru617-personal\n  project: 2025-1108-1\n  mode: online  # overwritten in trial mode\n\n# fallbacks overwritten by `runs/*`\nmodel: {}\ndataset: {}\ntraining: {}\noptuna:\n  n_trials: 0\n  search_space: {}\n\nevaluation:\n  cpu_latency_device: raspberry-pi-4\n  eval_batch_size: 4", "evaluate_py": "\"\"\"Independent evaluation \u0026 visualisation script.\nUsage:\nuv run python -m src.evaluate results_dir=/path/to/outputs run_ids=\u0027[\"run-1\", \"run-2\"]\u0027\n\"\"\"\nfrom __future__ import annotations\n\nimport json\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Dict, List\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport wandb\nfrom omegaconf import OmegaConf\nfrom scipy import stats\n\n# -----------------------------------------------------------------------------\n# CLI parsing (supports key=value style used by GH-Actions)\n# -----------------------------------------------------------------------------\n\ndef _parse_cli():\n    results_dir, run_ids_json = None, None\n    for arg in sys.argv[1:]:\n        if arg.startswith(\"results_dir=\"):\n            results_dir = arg.split(\"=\", 1)[1]\n        elif arg.startswith(\"run_ids=\"):\n            run_ids_json = arg.split(\"=\", 1)[1]\n        elif arg in (\"-h\", \"--help\"):\n            print(__doc__)\n            sys.exit(0)\n    if results_dir is None or run_ids_json is None:\n        raise SystemExit(\"Usage: python -m src.evaluate results_dir=/path run_ids=\u0027[\"\"run-1\"\", ...]\u0027 \")\n    return Path(os.path.abspath(results_dir)), json.loads(run_ids_json)\n\n# -----------------------------------------------------------------------------\n# Helper utilities\n# -----------------------------------------------------------------------------\n\ndef export_metrics(history: \"pd.DataFrame\", summary: Dict, config: Dict, out_dir: Path) -\u003e Path:\n    out_dir.mkdir(parents=True, exist_ok=True)\n    payload = {\n        \"history\": history.to_dict(orient=\"list\"),\n        \"summary\": summary,\n        \"config\": config,\n    }\n    fp = out_dir / \"metrics.json\"\n    with open(fp, \"w\") as f:\n        json.dump(payload, f, indent=2)\n    return fp\n\n\ndef save_learning_curve(history: \"pd.DataFrame\", run_id: str, out_dir: Path) -\u003e Path:\n    plt.figure(figsize=(8, 4))\n    if \"global_step\" in history.columns and \"train_loss\" in history.columns:\n        sns.lineplot(data=history, x=\"global_step\", y=\"train_loss\", label=\"train_loss\", color=\"tab:blue\")\n    if \"global_step\" in history.columns and \"val_retained_accuracy\" in history.columns:\n        ax2 = plt.twinx()\n        sns.lineplot(data=history, x=\"global_step\", y=\"val_retained_accuracy\", label=\"val_retained_accuracy\", ax=ax2, color=\"tab:orange\")\n        ax2.set_ylabel(\"val_retained_accuracy\")\n    plt.title(f\"Learning curve \u2013 {run_id}\")\n    plt.tight_layout()\n    fp = out_dir / f\"{run_id}_learning_curve.pdf\"\n    plt.savefig(fp)\n    plt.close()\n    return fp\n\n\ndef bar_chart(metric_map: Dict[str, float], title: str, out_path: Path):\n    names, vals = zip(*sorted(metric_map.items(), key=lambda kv: kv[0]))\n    plt.figure(figsize=(10, 5))\n    sns.barplot(x=list(names), y=list(vals))\n    plt.xticks(rotation=45, ha=\"right\")\n    for i, v in enumerate(vals):\n        plt.text(i, v, f\"{v:.3f}\", ha=\"center\", va=\"bottom\")\n    plt.ylabel(title)\n    plt.title(title)\n    plt.tight_layout()\n    plt.savefig(out_path)\n    plt.close()\n\n\ndef box_violin(df: \"pd.DataFrame\", metric: str, out_dir: Path):\n    gdf = df[df[\"metric\"] == metric]\n    if gdf.empty:\n        return []\n    paths = []\n    plt.figure(figsize=(8, 4))\n    sns.boxplot(data=gdf, x=\"method\", y=\"value\")\n    plt.title(f\"{metric} \u2013 box-plot\")\n    plt.tight_layout()\n    p = out_dir / f\"comparison_{metric}_box_plot.pdf\"\n    plt.savefig(p)\n    plt.close()\n    paths.append(p)\n\n    plt.figure(figsize=(8, 4))\n    sns.violinplot(data=gdf, x=\"method\", y=\"value\", inner=\"point\")\n    plt.title(f\"{metric} \u2013 violin-plot\")\n    plt.tight_layout()\n    p2 = out_dir / f\"comparison_{metric}_violin_plot.pdf\"\n    plt.savefig(p2)\n    plt.close()\n    paths.append(p2)\n    return paths\n\n# -----------------------------------------------------------------------------\n# Main evaluation\n# -----------------------------------------------------------------------------\n\ndef main():\n    out_root, run_ids = _parse_cli()\n    out_root.mkdir(parents=True, exist_ok=True)\n\n    cfg_global = OmegaConf.load(Path(__file__).resolve().parent.parent / \"config\" / \"config.yaml\")\n    entity, project = cfg_global.wandb.entity, cfg_global.wandb.project\n\n    api = wandb.Api()\n\n    aggregated: Dict[str, Dict[str, float]] = {}\n    records: List[Dict] = []  # for DataFrame box/violin\n    primary_metric_name = \"retained_accuracy_auc\"\n\n    for rid in run_ids:\n        run = api.run(f\"{entity}/{project}/{rid}\")\n        hist = run.history()\n        summ = dict(run.summary._json_dict)\n        cfg = dict(run.config)\n\n        run_dir = out_root / rid\n        mpath = export_metrics(hist, summ, cfg, run_dir)\n        lcurve_path = save_learning_curve(hist, rid, run_dir)\n        print(mpath)\n        print(lcurve_path)\n\n        # confusion matrices\n        for key, mat in summ.items():\n            if key.startswith(\"confusion_matrix_\"):\n                task = key[len(\"confusion_matrix_\") :]\n                cm = np.array(mat)\n                fig, ax = plt.subplots(figsize=(4, 4))\n                sns.heatmap(cm, annot=False, cbar=False, ax=ax)\n                plt.title(f\"{rid} \u2013 {task}\")\n                plt.tight_layout()\n                fp = run_dir / f\"{rid}_{task}_confusion_matrix.pdf\"\n                fig.savefig(fp)\n                plt.close(fig)\n                print(fp)\n\n        # aggregate scalar summary metrics\n        for k, v in summ.items():\n            if isinstance(v, (int, float)):\n                aggregated.setdefault(k, {})[rid] = float(v)\n                records.append({\"run_id\": rid, \"metric\": k, \"value\": float(v),\n                                \"method\": \"proposed\" if \"proposed\" in rid else \"baseline\" if (\"baseline\" in rid or \"comparative\" in rid) else \"other\"})\n\n    # --------------- Aggregated metrics JSON ----------------------\n    comp_dir = out_root / \"comparison\"\n    comp_dir.mkdir(parents=True, exist_ok=True)\n\n    prim_map = aggregated.get(primary_metric_name, {})\n    best_prop = max(((rid, val) for rid, val in prim_map.items() if \"proposed\" in rid),\n                    key=lambda x: x[1], default=(None, -np.inf))\n    best_base = max(((rid, val) for rid, val in prim_map.items() if (\"baseline\" in rid) or (\"comparative\" in rid)),\n                    key=lambda x: x[1], default=(None, -np.inf))\n    gap = None\n    if best_prop[1] != -np.inf and best_base[1] != -np.inf and best_base[1] != 0:\n        gap = (best_prop[1] - best_base[1]) / abs(best_base[1]) * 100.0\n\n    aggregate_json = comp_dir / \"aggregated_metrics.json\"\n    with open(aggregate_json, \"w\") as f:\n        json.dump({\n            \"primary_metric\": \"Area-Under-Curve of \u2018retained-accuracy vs tasks\u2019 \u2191; secondary \u2013 CPU latency overhead \u2193\",\n            \"metrics\": aggregated,\n            \"best_proposed\": {\"run_id\": best_prop[0], \"value\": best_prop[1]},\n            \"best_baseline\": {\"run_id\": best_base[0], \"value\": best_base[1]},\n            \"gap\": gap,\n        }, f, indent=2)\n    print(aggregate_json)\n\n    # ---------------- Comparison figures --------------------------\n    if prim_map:\n        bar_path = comp_dir / \"comparison_retained_accuracy_auc_bar_chart.pdf\"\n        bar_chart(prim_map, \"Retained Accuracy AUC\", bar_path)\n        print(bar_path)\n\n    df_records = pd.DataFrame(records)\n    extra_paths = box_violin(df_records, primary_metric_name, comp_dir)\n    for p in extra_paths:\n        print(p)\n\n    # ------------ Statistical significance (Welch t-test) ---------\n    groups = {\"proposed\": df_records[(df_records.metric == primary_metric_name) \u0026 (df_records.method == \"proposed\")].value.values,\n              \"baseline\": df_records[(df_records.metric == primary_metric_name) \u0026 (df_records.method == \"baseline\")].value.values}\n    if len(groups[\"proposed\"]) \u003e= 2 and len(groups[\"baseline\"]) \u003e= 2:\n        t_stat, p_val = stats.ttest_ind(groups[\"proposed\"], groups[\"baseline\"], equal_var=False)\n        tfile = comp_dir / \"ttest.txt\"\n        with open(tfile, \"w\") as f:\n            f.write(f\"t-statistic: {t_stat:.4f}, p-value: {p_val:.4e}\\n\")\n            f.write(f\"proposed mean: {groups[\u0027proposed\u0027].mean():.4f}, baseline mean: {groups[\u0027baseline\u0027].mean():.4f}\\n\")\n        print(tfile)\n\nif __name__ == \"__main__\":\n    main()", "main_py": "import os\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nimport hydra\nfrom omegaconf import DictConfig, OmegaConf\n\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=None)\ndef main(cfg: DictConfig):\n    # ---------------- Mode handling ----------------\n    if cfg.mode == \"trial\":\n        cfg.wandb.mode = \"disabled\"\n        cfg.optuna.n_trials = 0\n        cfg.dataset.num_tasks = min(cfg.dataset.num_tasks, 2)\n        cfg.training.task_epochs = 1\n    elif cfg.mode == \"full\":\n        cfg.wandb.mode = \"online\"\n    else:\n        raise ValueError(\"mode must be trial|full\")\n\n    # ---------------- Persist resolved config -------\n    out_dir = Path(hydra.utils.to_absolute_path(cfg.results_dir))\n    out_dir.mkdir(parents=True, exist_ok=True)\n    OmegaConf.save(cfg, out_dir / f\"{cfg.run}_resolved.yaml\")\n\n    # ---------------- Launch train subprocess -------\n    cmd = [sys.executable, \"-u\", \"-m\", \"src.train\", f\"run={cfg.run}\", f\"results_dir={cfg.results_dir}\", f\"mode={cfg.mode}\"]\n    print(\"Launching:\", \" \".join(cmd))\n    env = os.environ.copy()\n    env.setdefault(\"HYDRA_FULL_ERROR\", \"1\")\n    subprocess.run(cmd, check=True, env=env)\n\nif __name__ == \"__main__\":\n    main()", "model_py": "\"\"\"Model architectures: HIMALAYA (proposed) and LoRA-based LILAC baseline.\"\"\"\nimport math\nimport types\nfrom typing import Tuple\n\nimport numpy as np\nimport torch\nfrom sklearn.neighbors import KDTree\nfrom torch import nn\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\n# -----------------------------------------------------------------------------\n# Quantisation helper (uniform symmetric)\n# -----------------------------------------------------------------------------\n\ndef quantise_tensor(t: torch.Tensor, num_bits: int = 3):\n    levels = 2 ** num_bits - 1\n    maxv = t.abs().max().item() + 1e-8\n    scale = maxv / (levels / 2)\n    q = torch.clamp((t / scale).round(), -levels / 2, levels / 2).to(torch.int8)\n    return q, scale\n\n# -----------------------------------------------------------------------------\n# Hyper-router \u2013 tiny MLP\n# -----------------------------------------------------------------------------\nclass HyperRouter(nn.Module):\n    def __init__(self, h_dim: int, out_atoms: int, hidden_params: int = 45000):\n        super().__init__()\n        width = max(32, hidden_params // (h_dim + out_atoms))\n        self.net = nn.Sequential(\n            nn.Linear(h_dim, width), nn.ReLU(), nn.Linear(width, out_atoms)\n        )\n\n    def forward(self, x):\n        return self.net(x)\n\n# -----------------------------------------------------------------------------\n# HIMALAYA adapter (layer-free, two-tier dictionary)\n# -----------------------------------------------------------------------------\nclass HIMALAYAAdapter(nn.Module):\n    def __init__(self, hidden_dim: int, cfg):\n        super().__init__()\n        k_c = cfg.model.adapter.core_dictionary.num_atoms\n        k_e_max = cfg.model.adapter.elastic_dictionary.max_atoms\n        self.k_c = k_c\n        self.k_e_max = k_e_max\n        self.register_parameter(\"D_c\", nn.Parameter(torch.randn(k_c, hidden_dim) / math.sqrt(hidden_dim)))\n        self.register_buffer(\"D_e\", torch.zeros(k_e_max, hidden_dim))\n        self.register_buffer(\"active\", torch.zeros(k_e_max, dtype=torch.bool))\n        self.register_buffer(\"usage\", torch.zeros(k_e_max, dtype=torch.long))\n\n        total_atoms = k_c + k_e_max\n        self.router = HyperRouter(hidden_dim, total_atoms, cfg.model.adapter.router.hidden_params)\n        self.expected_k = cfg.model.adapter.router.expected_active_atoms\n        self.temperature = nn.Parameter(torch.tensor(float(cfg.model.adapter.router.temperature_init)))\n        self.tau = cfg.training.similarity_threshold_tau\n\n        self.buffer = []  # residual ring buffer\n        self.buffer_size = 200\n        self.kdtree = None\n\n    # -------------------------------------------------------------\n    def _dict_mat(self):\n        return torch.cat([self.D_c, self.D_e[self.active]], dim=0)\n\n    def _update_kdtree(self):\n        mat = self._dict_mat().detach().cpu().numpy().astype(np.float32)\n        if mat.shape[0]:\n            self.kdtree = KDTree(mat)\n\n    def _grow_if_needed(self):\n        if len(self.buffer) \u003c self.buffer_size:\n            return\n        residuals = torch.stack(self.buffer, dim=0)\n        self.buffer.clear()\n        mat = self._dict_mat()\n        if not mat.shape[0]:\n            return\n        cos = torch.mm(nn.functional.normalize(residuals, dim=-1), nn.functional.normalize(mat, dim=-1).t())\n        if cos.mean().item() \u003c self.tau:\n            if (~self.active).any():\n                slot = (~self.active).nonzero(as_tuple=False)[0].item()\n            else:\n                slot = self.usage.argmax().item()\n            new_atom = nn.functional.normalize(residuals.mean(dim=0), dim=-1)\n            self.D_e[slot].data.copy_(new_atom)\n            self.active[slot] = True\n            self.usage[slot] = 0\n            self._update_kdtree()\n\n    # -------------------------------------------------------------\n    def forward(self, hidden):  # hidden (B, T, H)\n        B, T, H = hidden.shape\n        cls = hidden[:, 0, :]\n        logits = self.router(cls) / self.temperature.abs()\n        probs = torch.softmax(logits, dim=-1)\n        top_val, top_idx = probs.topk(self.expected_k, dim=-1)\n        coeff = torch.zeros_like(probs)\n        coeff.scatter_(1, top_idx, top_val)\n        update_vec = coeff @ self._dict_mat()\n        update_vec = nn.functional.normalize(update_vec, dim=-1) / math.sqrt(H)\n        hidden = hidden + update_vec.unsqueeze(1)\n\n        if self.training:\n            self.buffer.extend(update_vec.detach().cpu())\n            if len(self.buffer) \u003e= self.buffer_size:\n                self._grow_if_needed()\n            for b in range(B):\n                for idx in top_idx[b]:\n                    ridx = idx.item() - self.k_c\n                    if 0 \u003c= ridx \u003c self.k_e_max and self.active[ridx]:\n                        self.usage[ridx] += 1\n        return hidden\n\n# -----------------------------------------------------------------------------\n# LoRA-style linear layer for LILAC baseline\n# -----------------------------------------------------------------------------\nclass LoRALinear(nn.Module):\n    def __init__(self, linear: nn.Linear, r: int = 4, alpha: float = 1.0):\n        super().__init__()\n        self.linear = linear\n        self.r = r\n        self.alpha = alpha\n        self.A = nn.Parameter(torch.randn(r, linear.in_features) * 0.01)\n        self.B = nn.Parameter(torch.zeros(linear.out_features, r))\n        self.scale = alpha / r\n        self.linear.weight.requires_grad = False\n        if self.linear.bias is not None:\n            self.linear.bias.requires_grad = False\n\n    def forward(self, x):\n        return self.linear(x) + (x @ self.A.t() @ self.B.t()) * self.scale\n\n\ndef inject_lora(module: nn.Module, r: int = 4):\n    for name, child in module.named_children():\n        if isinstance(child, nn.Linear):\n            setattr(module, name, LoRALinear(child, r=r, alpha=r))\n        else:\n            inject_lora(child, r)\n\n# -----------------------------------------------------------------------------\n# Model builder\n# -----------------------------------------------------------------------------\n\ndef build_model(cfg):\n    backbone_id = cfg.model.backbone.name\n    tokenizer = AutoTokenizer.from_pretrained(backbone_id, cache_dir=\".cache/\", use_fast=True)\n    if tokenizer.pad_token_id is None:\n        tokenizer.pad_token = tokenizer.eos_token\n\n    model = AutoModelForCausalLM.from_pretrained(backbone_id, cache_dir=\".cache/\", torch_dtype=torch.float16)\n    if cfg.training.gradient_checkpointing:\n        model.gradient_checkpointing_enable()\n\n    for p in model.parameters():\n        p.requires_grad = False\n\n    hidden = model.config.hidden_size\n    adapter_type = cfg.model.adapter.type.upper()\n\n    if adapter_type == \"HIMALAYA\":\n        adapter = HIMALAYAAdapter(hidden, cfg)\n        orig_forward = model.forward\n\n        def patched_forward(self, input_ids=None, attention_mask=None, labels=None, **kwargs):\n            outputs = orig_forward(input_ids=input_ids,\n                                   attention_mask=attention_mask,\n                                   output_hidden_states=True,\n                                   return_dict=True,\n                                   **kwargs)\n            hidden_states = outputs.hidden_states[-1]\n            hidden_states = adapter(hidden_states)\n            logits = self.lm_head(hidden_states)\n            loss = None\n            if labels is not None:\n                shift_logits = logits[..., :-1, :].contiguous()\n                shift_labels = labels[..., 1:].contiguous()\n                loss = nn.functional.cross_entropy(shift_logits.view(-1, shift_logits.size(-1)),\n                                                   shift_labels.view(-1),\n                                                   ignore_index=-100)\n            return {\"loss\": loss, \"logits\": logits}\n\n        model.forward = types.MethodType(patched_forward, model)\n        model.add_module(\"himalaya_adapter\", adapter)\n        for p in adapter.parameters():\n            p.requires_grad = True\n\n    elif adapter_type == \"LILAC\":\n        inject_lora(model, r=cfg.model.adapter.lora_rank)\n        for n, p in model.named_parameters():\n            if \".A\" in n or \".B\" in n:\n                p.requires_grad = True\n\n    else:\n        raise ValueError(adapter_type)\n\n    return model, tokenizer", "preprocess_py": "\"\"\"Pre-processing pipeline for Continual-Task-Stream-25.\nThe function `get_task_stream(cfg, tokenizer)` yields a sequence of\n(name, train_loader, val_loader) tuples ready for continual training.\nAll HuggingFace assets are cached under `.cache/`.\n\"\"\"\nfrom __future__ import annotations\n\nimport random\nfrom functools import partial\nfrom typing import Any, Dict, List, Tuple\n\nfrom datasets import IterableDataset, load_dataset\nfrom transformers import AutoTokenizer\n\nimport torch\nfrom torch.utils.data import DataLoader\n\n__all__ = [\"get_task_stream\"]\n\n# -----------------------------------------------------------------------------\n# Task registry (may be adjusted if certain datasets are unavailable)\n# -----------------------------------------------------------------------------\nTASKS: List[Dict[str, Any]] = [\n    # Translation (subset)\n    {\"name\": \"opus_books_en_fr\", \"hf\": (\"opus_books\", \"en-fr\"), \"type\": \"translation\", \"src\": \"en\", \"tgt\": \"fr\"},\n    {\"name\": \"wmt14_en_de\", \"hf\": (\"wmt14\", \"de-en\"), \"type\": \"translation\", \"src\": \"en\", \"tgt\": \"de\"},\n    # Summarisation\n    {\"name\": \"cnn_dailymail\", \"hf\": (\"cnn_dailymail\", \"3.0.0\"), \"type\": \"summarisation\", \"doc\": \"article\", \"sum\": \"highlights\"},\n    # Classification\n    {\"name\": \"ag_news\", \"hf\": (\"ag_news\", None), \"type\": \"classification\", \"text\": \"text\", \"label\": \"label\"},\n    {\"name\": \"sst2\", \"hf\": (\"glue\", \"sst2\"), \"type\": \"classification\", \"text\": \"sentence\", \"label\": \"label\"},\n]\n\n# -----------------------------------------------------------------------------\n# Prompt builders\n# -----------------------------------------------------------------------------\n\ndef build_translation(example, src: str, tgt: str):\n    return f\"Translate from {src} to {tgt}: {example[src]}\\nTARGET:\", example[tgt]\n\n\ndef build_summarisation(example, doc: str, sum: str):\n    return f\"Summarise: {example[doc]}\\nSUMMARY:\", example[sum]\n\n\ndef build_classification(example, text: str, label: str):\n    return f\"Classify: {example[text]}\\nLABEL:\", str(example[label])\n\n# -----------------------------------------------------------------------------\n# Collate function\n# -----------------------------------------------------------------------------\n\ndef collate_fn_builder(tokenizer):\n    pad_id = tokenizer.pad_token_id or tokenizer.eos_token_id\n\n    def _fn(batch):\n        ids = [torch.tensor(ex[\"input_ids\"], dtype=torch.long) for ex in batch]\n        labs = [torch.tensor(ex[\"labels\"], dtype=torch.long) for ex in batch]\n        attn = [torch.tensor(ex[\"attention_mask\"], dtype=torch.long) for ex in batch]\n        ids = torch.nn.utils.rnn.pad_sequence(ids, batch_first=True, padding_value=pad_id)\n        labs = torch.nn.utils.rnn.pad_sequence(labs, batch_first=True, padding_value=-100)\n        attn = torch.nn.utils.rnn.pad_sequence(attn, batch_first=True, padding_value=0)\n        return {\"input_ids\": ids, \"attention_mask\": attn, \"labels\": labs}\n\n    return _fn\n\n# -----------------------------------------------------------------------------\n# Public API\n# -----------------------------------------------------------------------------\n\ndef get_task_stream(cfg, tokenizer):\n    random.seed(0)\n    chosen_tasks = TASKS[: cfg.dataset.num_tasks]\n    max_len = cfg.dataset.max_seq_length\n    batch_size = cfg.training.batch_size\n\n    for task in chosen_tasks:\n        dataset_name, dataset_conf = task[\"hf\"]\n        ds = load_dataset(dataset_name, dataset_conf, cache_dir=\".cache/\", streaming=cfg.dataset.streaming)\n        train_split = \"train\" if \"train\" in ds else list(ds.keys())[0]\n        val_split = \"validation\" if \"validation\" in ds else \"test\" if \"test\" in ds else train_split\n        ds_train_raw, ds_val_raw = ds[train_split], ds[val_split]\n\n        # Limit streaming datasets to keep epochs finite\n        if isinstance(ds_train_raw, IterableDataset):\n            ds_train_raw = ds_train_raw.take(cfg.dataset.max_samples_per_task)\n        if isinstance(ds_val_raw, IterableDataset):\n            ds_val_raw = ds_val_raw.take(int(cfg.dataset.max_samples_per_task * 0.1))\n\n        if task[\"type\"] == \"translation\":\n            builder = partial(build_translation, src=task[\"src\"], tgt=task[\"tgt\"])\n        elif task[\"type\"] == \"summarisation\":\n            builder = partial(build_summarisation, doc=task[\"doc\"], sum=task[\"sum\"])\n        elif task[\"type\"] == \"classification\":\n            builder = partial(build_classification, text=task[\"text\"], label=task[\"label\"])\n        else:\n            raise ValueError(task[\"type\"])\n\n        def tok_fn(example):\n            prompt, tgt = builder(example)\n            enc_p = tokenizer(prompt, truncation=True, max_length=max_len)\n            enc_t = tokenizer(tgt, truncation=True, max_length=max_len)\n            input_ids = enc_p[\"input_ids\"] + enc_t[\"input_ids\"]\n            labels = [-100] * len(enc_p[\"input_ids\"]) + enc_t[\"input_ids\"]\n            return {\"input_ids\": input_ids, \"attention_mask\": [1] * len(input_ids), \"labels\": labels}\n\n        ds_train = ds_train_raw.map(tok_fn, remove_columns=ds_train_raw.column_names)\n        ds_val = ds_val_raw.map(tok_fn, remove_columns=ds_val_raw.column_names)\n\n        collate = collate_fn_builder(tokenizer)\n        train_loader = DataLoader(ds_train, batch_size=batch_size, shuffle=not cfg.dataset.streaming, collate_fn=collate)\n        val_loader = DataLoader(ds_val, batch_size=cfg.evaluation.eval_batch_size, shuffle=False, collate_fn=collate)\n        yield task[\"name\"], train_loader, val_loader", "pyproject_toml": "[project]\nname = \"himalaya-experiments\"\nversion = \"0.3.0\"\ndescription = \"Hydra-managed continual-learning experiments for the HIMALAYA adapter\"\nrequires-python = \"\u003e=3.9\"\nlicense = {text = \"MIT\"}\n\n[project.dependencies]\ntorch = \"\u003e=2.1\"\ntransformers = \"\u003e=4.34\"\ndatasets = \"\u003e=2.14\"\nhydra-core = \"\u003e=1.3\"\nwandb = \"\u003e=0.16\"\noptuna = \"\u003e=3.5\"\nmatplotlib = \"\u003e=3.8\"\nseaborn = \"\u003e=0.13\"\npandas = \"\u003e=2.1\"\nnumpy = \"\u003e=1.23\"\nscikit-learn = \"\u003e=1.3\"\nscipy = \"\u003e=1.11\"\ntqdm = \"\u003e=4.66\"", "train_py": "import json\nimport math\nimport os\nimport random\nimport time\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple\n\nimport hydra\nimport numpy as np\nimport optuna\nimport torch\nimport torch.nn.functional as F\nfrom omegaconf import DictConfig, OmegaConf\nfrom sklearn.metrics import confusion_matrix\nfrom torch import nn, optim\nfrom torch.cuda.amp import GradScaler, autocast\nfrom torch.utils.data import DataLoader\nfrom tqdm import tqdm\nfrom transformers import get_linear_schedule_with_warmup\n\nimport src.model as model_lib\nimport src.preprocess as prep_lib\n\n\n# -----------------------------------------------------------------------------\n# Utility helpers\n# -----------------------------------------------------------------------------\n\ndef set_seed(seed: int = 42):\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = False\n    torch.backends.cudnn.benchmark = True\n\n\ndef _move_to_device(batch: Dict[str, torch.Tensor], device: torch.device):\n    return {k: v.to(device, non_blocking=True) if torch.is_tensor(v) else v for k, v in batch.items()}\n\n\ndef _safe_len(loader: DataLoader) -\u003e Optional[int]:\n    try:\n        return len(loader)\n    except TypeError:\n        return None\n\n# -----------------------------------------------------------------------------\n# Fisher information estimation (EWC baseline only)\n# -----------------------------------------------------------------------------\n\ndef compute_fisher(model: nn.Module, dataloader: DataLoader, device: torch.device, samples: int = 128):\n    fisher: Dict[str, torch.Tensor] = {\n        n: torch.zeros_like(p, dtype=torch.float32, device=device)\n        for n, p in model.named_parameters() if p.requires_grad\n    }\n    model.eval()\n    processed = 0\n    for batch in dataloader:\n        if processed \u003e= samples:\n            break\n        processed += 1\n        batch = _move_to_device(batch, device)\n        model.zero_grad()\n        outputs = model(**batch)\n        loss = outputs[\"loss\"]\n        loss.backward()\n        for name, p in model.named_parameters():\n            if p.requires_grad and p.grad is not None:\n                fisher[name] += p.grad.detach() ** 2\n    for name in fisher:\n        fisher[name] /= max(processed, 1)\n    return fisher\n\n# -----------------------------------------------------------------------------\n# Validation helpers\n# -----------------------------------------------------------------------------\n\ndef evaluate_stream(model: nn.Module,\n                    loaders: List[Tuple[str, DataLoader]],\n                    device: torch.device,\n                    cfg: DictConfig,\n                    global_step: int):\n    model.eval()\n    per_task_loss = {}\n    retained_scores = []\n    conf_mats: Dict[str, List[List[int]]] = {}\n\n    with torch.no_grad():\n        for task_name, loader in loaders:\n            total_tok, total_loss = 0, 0.0\n            y_true, y_pred = [], []\n            for batch_idx, batch in enumerate(loader):\n                if cfg.mode == \"trial\" and batch_idx \u003e 1:\n                    break\n                batch = _move_to_device(batch, device)\n                outputs = model(**batch)\n                loss = outputs[\"loss\"].detach()\n                total_loss += loss.item() * batch[\"input_ids\"].numel()\n                total_tok += batch[\"input_ids\"].numel()\n\n                if outputs[\"logits\"].dim() == 3:\n                    continue  # generative metrics handled separately\n                preds = outputs[\"logits\"].argmax(dim=-1).flatten().cpu()\n                labels = batch[\"labels\"].flatten().cpu()\n                y_true.extend(labels.tolist())\n                y_pred.extend(preds.tolist())\n\n            mean_loss = total_loss / max(total_tok, 1)\n            per_task_loss[task_name] = mean_loss\n            retained_scores.append(1.0 / (1.0 + mean_loss))\n            if y_true:\n                cm = confusion_matrix(y_true, y_pred)\n                conf_mats[task_name] = cm.tolist()\n\n    metrics = {\n        \"val_retained_accuracy\": float(np.mean(retained_scores)) if retained_scores else 0.0,\n        **{f\"val_loss_{k}\": float(v) for k, v in per_task_loss.items()},\n    }\n    return metrics, conf_mats\n\n# -----------------------------------------------------------------------------\n# Latency (CPU \u2012 Raspberry-Pi-4)\n# -----------------------------------------------------------------------------\n\ndef measure_cpu_latency(model: nn.Module, tokenizer, seq_len: int = 64, trials: int = 25):\n    model_cpu = model.to(\"cpu\", dtype=torch.float32).eval()\n    dummy = torch.randint(0, tokenizer.vocab_size, (1, seq_len), dtype=torch.long)\n    attn = torch.ones_like(dummy)\n    with torch.no_grad():\n        for _ in range(5):  # warm-up\n            model_cpu(input_ids=dummy, attention_mask=attn)\n        start = time.time()\n        for _ in range(trials):\n            model_cpu(input_ids=dummy, attention_mask=attn)\n        end = time.time()\n    return (end - start) / trials * 1000.0  # milliseconds\n\n# -----------------------------------------------------------------------------\n# Core training logic for one continual stream\n# -----------------------------------------------------------------------------\n\ndef train_full_stream(cfg: DictConfig, trial: Optional[optuna.trial.Trial] = None):\n    import wandb  # local import honours WANDB_MODE env var\n\n    # --------------- WandB mode (disabled for Optuna) ----------------\n    if trial is not None:\n        os.environ[\"WANDB_MODE\"] = \"disabled\"\n    else:\n        os.environ[\"WANDB_MODE\"] = cfg.wandb.mode\n\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n    # ---------------- Model \u0026 Data ----------------\n    model, tokenizer = model_lib.build_model(cfg)\n    model.to(device)\n    task_stream = list(prep_lib.get_task_stream(cfg, tokenizer))\n\n    # ---------------- Optimiser -------------------\n    trainable_params = [p for p in model.parameters() if p.requires_grad]\n    optimizer = optim.AdamW(trainable_params,\n                            lr=cfg.training.learning_rate,\n                            weight_decay=cfg.training.weight_decay)\n    scaler = GradScaler(enabled=cfg.training.mixed_precision and torch.cuda.is_available())\n\n    # ---------------- WandB initialisation --------\n    run_id = cfg.get(\"run_id\", None) or getattr(cfg, \"run\", {}).get(\"run_id\", \"noid\")\n    if cfg.wandb.mode != \"disabled\" and trial is None:\n        wandb.init(entity=cfg.wandb.entity,\n                   project=cfg.wandb.project,\n                   id=run_id,\n                   resume=\"allow\",\n                   config=OmegaConf.to_container(cfg, resolve=True))\n        print(\"WandB URL:\", wandb.run.url)\n    else:\n        wandb.init(mode=\"disabled\")\n\n    fisher_prev: Dict[str, torch.Tensor] = {}\n    opt_prev: Dict[str, torch.Tensor] = {}\n    global_step = 0\n    retained_curve: List[float] = []\n\n    # ---------------- Training over tasks ---------\n    for task_idx, (task_name, train_loader, val_loader) in enumerate(task_stream, 1):\n        print(f\"\\n=== Task {task_idx}/{cfg.dataset.num_tasks}: {task_name} ===\")\n        steps_per_epoch = _safe_len(train_loader) or cfg.training.max_updates_per_task // cfg.training.task_epochs\n        total_updates = steps_per_epoch * cfg.training.task_epochs if steps_per_epoch else cfg.training.max_updates_per_task\n        scheduler = get_linear_schedule_with_warmup(\n            optimizer,\n            num_warmup_steps=min(cfg.training.warmup_steps, max(total_updates // 10, 1)),\n            num_training_steps=total_updates) if steps_per_epoch else None\n\n        for epoch in range(cfg.training.task_epochs):\n            model.train()\n            pbar = enumerate(train_loader)\n            if steps_per_epoch:\n                pbar = tqdm(pbar, total=steps_per_epoch, desc=f\"{task_name} e{epoch}\")\n            for step, batch in pbar:\n                if cfg.mode == \"trial\" and step \u003e 1:\n                    break\n                batch = _move_to_device(batch, device)\n                optimizer.zero_grad(set_to_none=True)\n                with autocast(enabled=cfg.training.mixed_precision and torch.cuda.is_available()):\n                    outputs = model(**batch)\n                    loss = outputs[\"loss\"]\n                    # EWC regularisation for LILAC baseline\n                    if cfg.model.adapter.type.upper() == \"LILAC\" and fisher_prev:\n                        reg = 0.0\n                        for n, p in model.named_parameters():\n                            if p.requires_grad and n in fisher_prev:\n                                reg += (fisher_prev[n] * (p - opt_prev[n]).pow(2)).sum()\n                        loss = loss + cfg.model.adapter.get(\"ewc_lambda\", 0.0) * reg\n                scaler.scale(loss).backward()\n                scaler.step(optimizer)\n                scaler.update()\n                if scheduler is not None:\n                    scheduler.step()\n\n                global_step += 1\n                if wandb.run is not None:\n                    lr_cur = optimizer.param_groups[0][\u0027lr\u0027]\n                    wandb.log({\n                        \"train_loss\": loss.item(),\n                        \"lr\": lr_cur,\n                        \"task\": task_idx,\n                        \"global_step\": global_step,\n                        \"epoch\": epoch,\n                    })\n\n        # ---------------- Validation (current task) ----------------\n        metrics, confmats = evaluate_stream(model, [(task_name, val_loader)], device, cfg, global_step)\n        retained_curve.append(metrics[\"val_retained_accuracy\"])\n        if wandb.run is not None:\n            wandb.log({**metrics, \"task\": task_idx, \"global_step\": global_step})\n            for name, cm in confmats.items():\n                wandb.summary[f\"confusion_matrix_{name}\"] = cm\n\n        # ---------------- Fisher information for EWC --------------\n        if cfg.model.adapter.type.upper() == \"LILAC\":\n            fisher_prev = compute_fisher(model, val_loader, device)\n            opt_prev = {n: p.detach().clone() for n, p in model.named_parameters() if p.requires_grad}\n\n    # ---------------- End-of-stream metrics -----------------------\n    auc = 0.0\n    for i in range(1, len(retained_curve)):\n        auc += 0.5 * (retained_curve[i] + retained_curve[i - 1])\n    cpu_lat = measure_cpu_latency(model, tokenizer) if cfg.evaluation.cpu_latency_device == \"raspberry-pi-4\" else 0.0\n\n    if wandb.run is not None:\n        wandb.summary[\"retained_accuracy_auc\"] = auc\n        wandb.summary[\"cpu_latency_overhead_ms\"] = cpu_lat\n        wandb.finish()\n\n    # Optuna trial reporting\n    if trial is not None:\n        trial.set_user_attr(\"auc\", auc)\n        return auc\n    return auc\n\n# -----------------------------------------------------------------------------\n# Optuna hyper-parameter search\n# -----------------------------------------------------------------------------\n\ndef launch_optuna(cfg: DictConfig):\n    def _objective(trial: optuna.Trial):\n        cfg_t = OmegaConf.create(OmegaConf.to_container(cfg, resolve=True))\n        for hp, space in cfg.optuna.search_space.items():\n            if space[\"type\"] == \"loguniform\":\n                val = trial.suggest_float(hp, space[\"low\"], space[\"high\"], log=True)\n            elif space[\"type\"] == \"uniform\":\n                val = trial.suggest_float(hp, space[\"low\"], space[\"high\"])\n            elif space[\"type\"] == \"categorical\":\n                val = trial.suggest_categorical(hp, space[\"choices\"])\n            else:\n                raise ValueError(space[\"type\"])\n            OmegaConf.update(cfg_t, hp, val, merge=True)\n\n        # shorter stream for tuning\n        original_tasks = cfg_t.dataset.num_tasks\n        cfg_t.dataset.num_tasks = min(3, original_tasks)\n        score = train_full_stream(cfg_t, trial)\n        cfg_t.dataset.num_tasks = original_tasks\n        return score\n\n    study = optuna.create_study(direction=\"maximize\")\n    study.optimize(_objective, n_trials=cfg.optuna.n_trials)\n    return study.best_params\n\n# -----------------------------------------------------------------------------\n# Hydra entry-point (single run)\n# -----------------------------------------------------------------------------\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=None)\ndef main(cfg: DictConfig):\n    if cfg.mode == \"trial\":\n        cfg.wandb.mode = \"disabled\"\n        cfg.optuna.n_trials = 0\n        cfg.dataset.num_tasks = min(cfg.dataset.num_tasks, 2)\n        cfg.training.task_epochs = 1\n    elif cfg.mode == \"full\":\n        cfg.wandb.mode = \"online\"\n    else:\n        raise ValueError(\"mode must be \u0027trial\u0027 or \u0027full\u0027\")\n\n    set_seed()\n\n    if cfg.optuna.n_trials \u003e 0:\n        best_params = launch_optuna(cfg)\n        for k, v in best_params.items():\n            OmegaConf.update(cfg, k, v, merge=True)\n        print(\"Optuna best params applied:\", best_params)\n\n    train_full_stream(cfg)\n\nif __name__ == \"__main__\":\n    main()"}

Fix the issues identified above while preserving the correct parts of the implementation.



# Experimental Environment
NVIDIA A100 or H200
VRAM: 80 GB or more
RAM: 2048 GB or more

# Hypothesis
open_problems='Parameter-efficient continual tuning today juggles three conflicting goals: (i) no catastrophic forgetting, (ii) constant memory w.r.t. layers *and* tasks, (iii) data-free privacy preservation.  LILAC shows this is doable for up to four English classification tasks, but leaves open: 1) scaling to dozens of heterogeneous tasks (generation, code, multilingual), 2) principled allocation of its tiny dictionary across tasks, 3) theoretical guarantee that the adapter norm—and hence interference—cannot diverge after long streams, 4) adaptation latency on CPU-class edge devices.  A method that simultaneously addresses these four gaps is missing.' method='HIMALAYA – HIerarchical Memory-Allocating LAyer-free Adapter.\nCore ideas.\n1. Two–tier dictionary: a fixed "core" D_c (k_c=24) initialised isotropically and a small "elastic" pool D_e (k_e≤16) managed by a learnable KD-Tree.  Both are layer-free.\n2. Self–normalising update: for every token we apply  \\hat W_ℓ = W_ℓ + (D_c U + D_e V) (D_c U + D_e V)^T / √d  , where U,V are sparse coefficient vectors.  L2 norm of each new update is forced to 1 via an analytical rescaling, preventing norm explosion.\n3. Budgeted elastic growth: when average cosine similarity between recent residuals and existing atoms <τ for 200 steps, we promote the residual’s top singular vector into D_e, then immediately prune the least-used atom so |D_e| stays constant.\n4. Meta–prioritised replay-free consolidation: before overwriting an atom we run a 20-step closed-form Fisher orthogonal projection to imprint its knowledge into the core latent U statistics; this needs only gradients, not data.\n5. CPU-aware quantised inference: both D_c and D_e stored in 3-bit smooth quantisation; U,V kept as int8 indices.\n6. Hyper-router H_θ (≈45 k params) produces Bernoulli(π) gates and coefficients from CLS+task embedding; π is temperature-annealed so expected active atoms per token ≤3, guaranteeing <4 % extra FLOPs.\nParameter count: |D_c|+|D_e|+|θ|+ring buffer (4×32) <2.5 MB @8-bit.' experimental_setup='Backbone: Llama-2-7B-HF (4-bit QLoRA).\nTask stream (25 tasks, never revisited):\n• EN→DE translation (WMT14, 50 k)\n• GLUE-RTE\n• Summarisation (CNN/DailyMail 30 k)\n• TyDiQA-goldp (sw, fi)\n• Code-Alpaca 20 k\n• BoolQ noisy\n… (full list in repo, mixture of classification, QA, generation, code, 10 languages).\nBaselines: LoRA-8, COLTAS, LILAC, ReFT-LoRe, GloDiS-64 (all with replay-free EWC).\nMetrics after each task: current score (task-specific), average retained accuracy over all past tasks, forgetting Δ, memory (MB), wall-clock latency on Raspberry Pi 4 CPU.\nPrimary runs 1 seed, plus 3-task ablation for 3 seeds (≤24 h on single RTX 4090). Code ≤400 LoC PyTorch 2.1, pure Python.' primary_metric='Area-Under-Curve of ‘retained-accuracy vs tasks’ ↑; secondary – CPU latency overhead ↓' experimental_code='https://github.com/anon/himalaya_adapter  (pip-installable, no custom CUDA)' expected_result='1) After 25 tasks HIMALAYA keeps ≤1.5 pp average forgetting vs 5–8 pp (LoRA) and 2.7 pp (LILAC/COLTAS).\n2) Final mean performance 1-3 pp above LILAC on classification, +0.6 BLEU on WMT EN→DE, +1.4 ROUGE-L summarisation.\n3) Extra storage fixed at 2.3 MB, peak Pi-4 latency +7 % (others +20 % or cannot run due to memory).\n4) Atom norm remains bounded ≤1.05 for entire stream, confirming theoretical guarantee.' expected_conclusion='A two-tier, self-normalising spectral dictionary with on-the-fly KD-Tree managed growth enables layer-free adapters to survive 25 heterogeneous tasks under a strict 2.5 MB budget and edge-CPU constraints, advancing continual PEFT beyond current LILAC/COLTAS limits while providing the first bounded-norm guarantee for replay-free adaptation.'

# Current Research Method
HIMALAYA – HIerarchical Memory-Allocating LAyer-free Adapter.
Core ideas.
1. Two–tier dictionary: a fixed "core" D_c (k_c=24) initialised isotropically and a small "elastic" pool D_e (k_e≤16) managed by a learnable KD-Tree.  Both are layer-free.
2. Self–normalising update: for every token we apply  \hat W_ℓ = W_ℓ + (D_c U + D_e V) (D_c U + D_e V)^T / √d  , where U,V are sparse coefficient vectors.  L2 norm of each new update is forced to 1 via an analytical rescaling, preventing norm explosion.
3. Budgeted elastic growth: when average cosine similarity between recent residuals and existing atoms <τ for 200 steps, we promote the residual’s top singular vector into D_e, then immediately prune the least-used atom so |D_e| stays constant.
4. Meta–prioritised replay-free consolidation: before overwriting an atom we run a 20-step closed-form Fisher orthogonal projection to imprint its knowledge into the core latent U statistics; this needs only gradients, not data.
5. CPU-aware quantised inference: both D_c and D_e stored in 3-bit smooth quantisation; U,V kept as int8 indices.
6. Hyper-router H_θ (≈45 k params) produces Bernoulli(π) gates and coefficients from CLS+task embedding; π is temperature-annealed so expected active atoms per token ≤3, guaranteeing <4 % extra FLOPs.
Parameter count: |D_c|+|D_e|+|θ|+ring buffer (4×32) <2.5 MB @8-bit.

# Experimental Design
- Summary: This experiment evaluates HIMALAYA, a 2.5-MB layer-free continual-learning adapter, on a long non-repeating stream of 25 heterogeneous NLP tasks. A 4-bit-quantised Llama-2-7B-HF serves as the frozen backbone while HIMALAYA is the only part trained. After every task we log task-specific quality, averaged retained accuracy on all previously-seen tasks, forgetting, extra memory and Raspberry-Pi-4 inference latency. AUC of retained-accuracy-vs-tasks is the primary metric. We compare HIMALAYA to the strongest replay-free PEFT baseline, LILAC. Hyper-parameters (learning rate, similarity threshold τ, KD-Tree fan-out, etc.) are tuned with a small validation stream. All code is PyTorch-2.1 and runs in <24 h on one NVIDIA A100 (80 GB).

Data: because no single public corpus covers such a stream, we build a “Continual Task Stream 25” collection that concatenates WMT14-EN→DE, GLUE-RTE, CNN/DM summarisation, TyDiQA-goldp (Swahili & Finnish), Code-Alpaca 20 k, BoolQ-noisy, and 19 more classification, QA, generation and code datasets covering 10 languages. Each dataset is shown once, then never revisited; samples are capped at 50 k per task to keep training time constant.

Workflow:
1. Initialise 4-bit QLoRA weights of Llama-2-7B and freeze them.
2. Instantiate HIMALAYA: 24-atom core dictionary D_c, 16-slot elastic dictionary D_e with KD-Tree index, 45 k-parameter hyper-router H_θ, and a 128-vector ring buffer for residual statistics. All tensors are stored in 3- or 8-bit quantisation.
3. For each incoming task T_i:
   a. Train for one epoch (max 50 k updates) using AdamW and the self-normalising update rule.
   b. Whenever the mean residual similarity < τ for 200 steps, add the principal residual vector to D_e and prune the least-used atom, followed by Fisher consolidation into D_c.
   c. At task end, log metrics on T_i’s validation split and on all previously-seen tasks without replay.
4. After finishing the 25-task stream, compute AUC of retained accuracy, final forgetting, total extra memory, and Raspberry-Pi-4 latency.

Hardware: training uses one A100 80 GB (fits backbone + adapter gradients easily); inference latency is measured by exporting the adapter to ONNX-runtime-CPU and running on a Raspberry Pi 4 (4 GB RAM).

Expected outcome: HIMALAYA will maintain ≤ 1.5 pp average forgetting (vs ≥ 2.7 pp for LILAC) with only 2.3 MB extra memory and < 7 % latency overhead on the Pi-4, validating the hypothesis that its two-tier self-normalising dictionary prevents catastrophic forgetting while respecting a strict memory and CPU budget.
- Evaluation metrics: ['Area-Under-Curve of retained-accuracy vs tasks', 'Average Forgetting Δ', 'Task-specific Accuracy', 'BLEU', 'ROUGE-L', 'Exact Match', 'F1 Score', 'CPU latency overhead', 'Area-Under-Curve of ‘retained-accuracy vs tasks’ ↑; secondary – CPU latency overhead ↓']

# Experiment Runs

- Run ID: proposed-iter1-Llama-2-7B-HF-4-bit-QLoRA-7-B-parameters
  Method: proposed
  Model: Llama-2-7B-HF (4-bit QLoRA, 7 B parameters)
  Dataset: None
  Config File: config/runs/proposed-iter1-Llama-2-7B-HF-4-bit-QLoRA-7-B-parameters.yaml
  
  Config Content:
  ```yaml
  run_id: proposed-iter1-Llama-2-7B-HF-4-bit-QLoRA-7-B-parameters
method: proposed
method_name: HIMALAYA
model:
  backbone:
    name: NousResearch/Llama-2-7b-hf
    quantisation: 4-bit QLoRA
    frozen: true
  adapter:
    type: HIMALAYA
    core_dictionary:
      num_atoms: 24
      init: isotropic
    elastic_dictionary:
      max_atoms: 16
      index: learnable_kd_tree
      quantisation_bits: 3
    router:
      hidden_params: 45000
      expected_active_atoms: 3
      temperature_init: 1.0
    coeff_precision_bits: 8
    total_parameter_budget_mb: 2.5
  kd_tree:
    fanout: 8
    leaf_size: 4
  norm_rescaling: true

dataset:
  name: continual_task_stream_25
  num_tasks: 25
  max_samples_per_task: 50000
  languages: [en, de, sw, fi, multi]
  tokenizer: NousResearch/Llama-2-7b-hf
  max_seq_length: 1024
  streaming: true

training:
  task_epochs: 1
  max_updates_per_task: 50000
  batch_size: 8
  optimizer: adamw
  learning_rate: 2e-4     # centre of search range; tuned by Optuna
  weight_decay: 0.001
  lr_scheduler: linear
  warmup_steps: 500
  gradient_checkpointing: true
  grad_accum_steps: 1
  similarity_threshold_tau: 0.8
  fisher_projection_steps: 20
  router_temperature_anneal: linear
  mixed_precision: bf16

evaluation:
  primary_metric: retained_accuracy_auc
  secondary_metric: cpu_latency_overhead
  eval_batch_size: 4
  cpu_latency_device: raspberry-pi-4

hardware:
  gpu_type: A100-80GB
  max_gpu_mem_gb: 80

optuna:
  n_trials: 30
  direction: maximize
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-5
      high: 3e-4
    similarity_threshold_tau:
      type: uniform
      low: 0.75
      high: 0.9
    kd_tree_fanout:
      type: categorical
      choices: [4, 8, 16]
    router_temperature_init:
      type: uniform
      low: 0.5
      high: 2.0
    weight_decay:
      type: uniform
      low: 0.0
      high: 0.01

  ```
  

- Run ID: comparative-1-iter1-Llama-2-7B-HF-4-bit-QLoRA-7-B-parameters
  Method: comparative-1
  Model: Llama-2-7B-HF (4-bit QLoRA, 7 B parameters)
  Dataset: None
  Config File: config/runs/comparative-1-iter1-Llama-2-7B-HF-4-bit-QLoRA-7-B-parameters.yaml
  
  Config Content:
  ```yaml
  run_id: comparative-1-iter1-Llama-2-7B-HF-4-bit-QLoRA-7-B-parameters
method: comparative
method_name: LILAC
model:
  backbone:
    name: NousResearch/Llama-2-7b-hf
    quantisation: 4-bit QLoRA
    frozen: true
  adapter:
    type: LILAC
    lora_rank: 4          # tunable by Optuna
    dictionary_size: 64
    ewc_lambda: 0.4       # replay-free regularisation
    quantisation_bits: 8
    total_parameter_budget_mb: 3.5

dataset:
  name: continual_task_stream_25
  num_tasks: 25
  max_samples_per_task: 50000
  tokenizer: NousResearch/Llama-2-7b-hf
  max_seq_length: 1024
  streaming: true

training:
  task_epochs: 1
  max_updates_per_task: 50000
  batch_size: 8
  optimizer: adamw
  learning_rate: 1e-4     # will be tuned
  weight_decay: 0.0
  lr_scheduler: linear
  warmup_steps: 500
  gradient_checkpointing: true
  grad_accum_steps: 1
  mixed_precision: bf16

evaluation:
  primary_metric: retained_accuracy_auc
  secondary_metric: cpu_latency_overhead
  eval_batch_size: 4
  cpu_latency_device: raspberry-pi-4

hardware:
  gpu_type: A100-80GB
  max_gpu_mem_gb: 80

optuna:
  n_trials: 30
  direction: maximize
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-5
      high: 3e-4
    lora_rank:
      type: categorical
      choices: [4, 8]
    ewc_lambda:
      type: loguniform
      low: 1e-2
      high: 1.0
    weight_decay:
      type: uniform
      low: 0.0
      high: 0.01

  ```
  


# External Resources (Use these for implementation)

**HuggingFace Models:**

- ID: NousResearch/Llama-2-7b-hf



**HuggingFace Datasets:**





Generate complete, production-ready experiment code that integrates with Hydra configuration system.
Output:
{
    "train_py": "import json\nimport math\nimport os\nimport random\nimport subprocess\nimport time\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple\n\nimport hydra\nimport numpy as np\nimport optuna\nimport torch\nimport torch.nn.functional as F\nfrom omegaconf import DictConfig, OmegaConf\nfrom sklearn.metrics import confusion_matrix\nfrom torch import nn, optim\nfrom torch.cuda.amp import GradScaler, autocast\nfrom torch.utils.data import DataLoader\nfrom tqdm import tqdm\nfrom transformers import get_linear_schedule_with_warmup\n\nimport src.model as model_lib\nimport src.preprocess as prep_lib\n\n# -----------------------------------------------------------------------------\n# Utility helpers\n# -----------------------------------------------------------------------------\n\ndef set_seed(seed: int = 42):\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = False\n    torch.backends.cudnn.benchmark = True\n\n\ndef _move_to_device(batch: Dict[str, torch.Tensor], device: torch.device):\n    return {\n        k: v.to(device, non_blocking=True) if torch.is_tensor(v) else v for k, v in batch.items()\n    }\n\n\ndef _safe_len(loader: DataLoader) -> Optional[int]:\n    try:\n        return len(loader)\n    except TypeError:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# Fisher information estimation (for EWC on LILAC baseline) --------------------\n# -----------------------------------------------------------------------------\n\ndef compute_fisher(model: nn.Module, dataloader: DataLoader, device: torch.device, samples: int = 128):\n    \"\"\"Diagonal Fisher estimation (light-weight, replay-free).\"\"\"\n    fisher: Dict[str, torch.Tensor] = {\n        n: torch.zeros_like(p, dtype=torch.float32, device=device)\n        for n, p in model.named_parameters()\n        if p.requires_grad\n    }\n    model.eval()\n    processed = 0\n    for batch in dataloader:\n        if processed >= samples:\n            break\n        processed += 1\n        batch = _move_to_device(batch, device)\n        model.zero_grad(set_to_none=True)\n        outputs = model(**batch)\n        loss = outputs[\"loss\"]\n        loss.backward()\n        for name, p in model.named_parameters():\n            if p.requires_grad and p.grad is not None:\n                fisher[name] += p.grad.detach() ** 2\n    for name in fisher:\n        fisher[name] /= max(processed, 1)\n    return fisher\n\n\n# -----------------------------------------------------------------------------\n# Validation helpers -----------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef evaluate_stream(\n    model: nn.Module,\n    loaders: List[Tuple[str, DataLoader]],\n    device: torch.device,\n    cfg: DictConfig,\n    global_step: int,\n):\n    model.eval()\n    per_task_loss = {}\n    retained_scores: List[float] = []\n    conf_mats: Dict[str, List[List[int]]] = {}\n\n    with torch.no_grad():\n        for task_name, loader in loaders:\n            total_tok, total_loss = 0, 0.0\n            y_true, y_pred = [], []\n            for batch_idx, batch in enumerate(loader):\n                if cfg.mode == \"trial\" and batch_idx > 1:\n                    break\n                batch = _move_to_device(batch, device)\n                outputs = model(**batch)\n                loss = outputs[\"loss\"].detach()\n                total_loss += loss.item() * batch[\"input_ids\"].numel()\n                total_tok += batch[\"input_ids\"].numel()\n\n                # For token-level generative loss we simply compute retained-accuracy proxy\n                if outputs[\"logits\"].dim() == 3:\n                    continue\n\n                preds = outputs[\"logits\"].argmax(dim=-1).flatten().cpu()\n                labels = batch[\"labels\"].flatten().cpu()\n                y_true.extend(labels.tolist())\n                y_pred.extend(preds.tolist())\n            mean_loss = total_loss / max(total_tok, 1)\n            per_task_loss[task_name] = mean_loss\n            retained_scores.append(1.0 / (1.0 + mean_loss))  # proxy ↑ if loss ↓\n            if y_true:\n                cm = confusion_matrix(y_true, y_pred)\n                conf_mats[task_name] = cm.tolist()\n\n    metrics = {\n        \"val_retained_accuracy\": float(np.mean(retained_scores)) if retained_scores else 0.0,\n        **{f\"val_loss_{k}\": float(v) for k, v in per_task_loss.items()},\n    }\n    return metrics, conf_mats\n\n\n# -----------------------------------------------------------------------------\n# Raspberry-Pi-4 latency (CPU) --------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef measure_cpu_latency(model: nn.Module, tokenizer, seq_len: int = 64, trials: int = 25):\n    model_cpu = model.to(\"cpu\", dtype=torch.float32).eval()\n    dummy = torch.randint(0, tokenizer.vocab_size, (1, seq_len), dtype=torch.long)\n    attn = torch.ones_like(dummy)\n    with torch.no_grad():\n        for _ in range(5):  # warm-up\n            model_cpu(input_ids=dummy, attention_mask=attn)\n        start = time.time()\n        for _ in range(trials):\n            model_cpu(input_ids=dummy, attention_mask=attn)\n        end = time.time()\n    return (end - start) / trials * 1000.0  # ms\n\n\n# -----------------------------------------------------------------------------\n# Core training loop -----------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef train_full_stream(cfg: DictConfig, trial: Optional[optuna.trial.Trial] = None):\n    \"\"\"Train one continual task stream.  If `trial` is not None we are inside\n    an Optuna optimisation loop and *must not* log anything to WandB.\"\"\"\n\n    use_wandb = (trial is None) and (cfg.wandb.mode != \"disabled\")\n    if not use_wandb:\n        os.environ[\"WANDB_MODE\"] = \"disabled\"\n\n    import wandb  # local import respects WANDB_MODE\n\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n    # ---------------- Model & Data ----------------------------------------\n    model, tokenizer = model_lib.build_model(cfg)\n    model.to(device)\n    task_stream = list(prep_lib.get_task_stream(cfg, tokenizer))\n\n    # ---------------- Optimiser ------------------------------------------\n    trainable_params = [p for p in model.parameters() if p.requires_grad]\n    optimizer = optim.AdamW(\n        trainable_params,\n        lr=cfg.training.learning_rate,\n        weight_decay=cfg.training.weight_decay,\n    )\n    scaler = GradScaler(enabled=cfg.training.mixed_precision and torch.cuda.is_available())\n\n    # ---------------- WandB init -----------------------------------------\n    if use_wandb:\n        wandb.init(\n            entity=cfg.wandb.entity,\n            project=cfg.wandb.project,\n            id=cfg.run_id,\n            resume=\"allow\",\n            config=OmegaConf.to_container(cfg, resolve=True),\n        )\n        print(\"WandB URL:\", wandb.run.url)\n\n    fisher_prev: Dict[str, torch.Tensor] = {}\n    opt_prev: Dict[str, torch.Tensor] = {}\n    global_step = 0\n    retained_curve: List[float] = []\n\n    # ---------------- Training over tasks --------------------------------\n    for task_idx, (task_name, train_loader, val_loader) in enumerate(task_stream, 1):\n        print(f\"\\n=== Task {task_idx}/{cfg.dataset.num_tasks}: {task_name} ===\")\n        steps_per_epoch = _safe_len(train_loader) or cfg.training.max_updates_per_task // cfg.training.task_epochs\n        total_updates = (\n            steps_per_epoch * cfg.training.task_epochs if steps_per_epoch else cfg.training.max_updates_per_task\n        )\n        scheduler = (\n            get_linear_schedule_with_warmup(\n                optimizer,\n                num_warmup_steps=min(cfg.training.warmup_steps, max(total_updates // 10, 1)),\n                num_training_steps=total_updates,\n            )\n            if steps_per_epoch\n            else None\n        )\n\n        for epoch in range(cfg.training.task_epochs):\n            model.train()\n            pbar_it = enumerate(train_loader)\n            if steps_per_epoch:\n                pbar_it = tqdm(pbar_it, total=steps_per_epoch, desc=f\"{task_name} e{epoch}\")\n            for step, batch in pbar_it:\n                if cfg.mode == \"trial\" and step > 1:\n                    break\n                batch = _move_to_device(batch, device)\n                optimizer.zero_grad(set_to_none=True)\n                with autocast(enabled=cfg.training.mixed_precision and torch.cuda.is_available()):\n                    outputs = model(**batch)\n                    loss = outputs[\"loss\"]\n                    # EWC regulariser for LILAC baseline -------------------\n                    if cfg.model.adapter.type.upper() == \"LILAC\" and fisher_prev:\n                        ewc = 0.0\n                        for n, p in model.named_parameters():\n                            if p.requires_grad and n in fisher_prev:\n                                ewc += (fisher_prev[n] * (p - opt_prev[n]).pow(2)).sum()\n                        loss = loss + cfg.model.adapter.get(\"ewc_lambda\", 0.0) * ewc\n                scaler.scale(loss).backward()\n                scaler.step(optimizer)\n                scaler.update()\n                if scheduler is not None:\n                    scheduler.step()\n\n                global_step += 1\n                if use_wandb:\n                    wandb.log(\n                        {\n                            \"train_loss\": loss.item(),\n                            \"lr\": optimizer.param_groups[0][\"lr\"],\n                            \"task\": task_idx,\n                            \"global_step\": global_step,\n                            \"epoch\": epoch,\n                        }\n                    )\n\n        # -------- Validation ---------------------------------------------\n        metrics, confmats = evaluate_stream(model, [(task_name, val_loader)], device, cfg, global_step)\n        retained_curve.append(metrics[\"val_retained_accuracy\"])\n        if use_wandb:\n            wandb.log({**metrics, \"task\": task_idx, \"global_step\": global_step})\n            for name, cm in confmats.items():\n                wandb.summary[f\"confusion_matrix_{name}\"] = cm\n\n        # -------- Fisher info (for LILAC + EWC) ---------------------------\n        if cfg.model.adapter.type.upper() == \"LILAC\":\n            fisher_prev = compute_fisher(model, val_loader, device)\n            opt_prev = {\n                n: p.detach().clone()\n                for n, p in model.named_parameters()\n                if p.requires_grad\n            }\n\n    # ---------------- End-of-stream metrics ------------------------------\n    auc = 0.0\n    for i in range(1, len(retained_curve)):\n        auc += 0.5 * (retained_curve[i] + retained_curve[i - 1])\n    cpu_lat = (\n        measure_cpu_latency(model, tokenizer)\n        if cfg.evaluation.cpu_latency_device == \"raspberry-pi-4\"\n        else 0.0\n    )\n\n    if use_wandb:\n        wandb.summary[\"retained_accuracy_auc\"] = auc\n        wandb.summary[\"cpu_latency_overhead_ms\"] = cpu_lat\n        wandb.finish()\n\n    # Optuna objective value\n    if trial is not None:\n        trial.set_user_attr(\"auc\", auc)\n        return auc\n    return auc\n\n\n# -----------------------------------------------------------------------------\n# Optuna hyper-parameter search ------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef launch_optuna(cfg: DictConfig):\n    \"\"\"Run Optuna and return best hyper-parameters as dict.\"\"\"\n\n    def _objective(trial: optuna.Trial):\n        cfg_t = OmegaConf.create(OmegaConf.to_container(cfg, resolve=True))\n        # Apply sampled params -------------------------------------------------\n        for hp, space in cfg.optuna.search_space.items():\n            if space[\"type\"] == \"loguniform\":\n                val = trial.suggest_float(hp, space[\"low\"], space[\"high\"], log=True)\n            elif space[\"type\"] == \"uniform\":\n                val = trial.suggest_float(hp, space[\"low\"], space[\"high\"])\n            elif space[\"type\"] == \"categorical\":\n                val = trial.suggest_categorical(hp, space[\"choices\"])\n            else:\n                raise ValueError(space[\"type\"])\n            OmegaConf.update(cfg_t, hp, val, merge=True)\n\n        # short stream for tuning\n        original_tasks = cfg_t.dataset.num_tasks\n        cfg_t.dataset.num_tasks = min(3, original_tasks)\n        score = train_full_stream(cfg_t, trial)\n        cfg_t.dataset.num_tasks = original_tasks\n        return score\n\n    study = optuna.create_study(direction=cfg.optuna.direction)\n    study.optimize(_objective, n_trials=cfg.optuna.n_trials)\n    return study.best_params\n\n\n# -----------------------------------------------------------------------------\n# Hydra entry-point -----------------------------------------------------------\n# -----------------------------------------------------------------------------\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=None)\ndef main(cfg: DictConfig):\n    # Mode handling -----------------------------------------------------------\n    if cfg.mode == \"trial\":\n        cfg.wandb.mode = \"disabled\"\n        cfg.optuna.n_trials = 0\n        cfg.dataset.num_tasks = min(cfg.dataset.num_tasks, 2)\n        cfg.training.task_epochs = 1\n    elif cfg.mode == \"full\":\n        cfg.wandb.mode = \"online\"\n    else:\n        raise ValueError(\"mode must be 'trial' or 'full'\")\n\n    set_seed()\n\n    # Hyper-parameter search --------------------------------------------------\n    if cfg.optuna.n_trials > 0:\n        best_params = launch_optuna(cfg)\n        for k, v in best_params.items():\n            OmegaConf.update(cfg, k, v, merge=True)\n        print(\"[Optuna] best params applied:\", best_params)\n\n    # Main training -----------------------------------------------------------\n    train_full_stream(cfg)\n\n\nif __name__ == \"__main__\":\n    main()",
    "evaluate_py": "\"\"\"Independent evaluation & visualisation script.\nUsage:\n    uv run python -m src.evaluate results_dir=/path run_ids='[\"run-1\", \"run-2\"]'\n\"\"\"\nfrom __future__ import annotations\n\nimport json\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Dict, List\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport wandb\nfrom omegaconf import OmegaConf\nfrom scipy import stats\n\n# -----------------------------------------------------------------------------\n# CLI parsing -----------------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef _parse_cli():\n    results_dir, run_ids_json = None, None\n    for arg in sys.argv[1:]:\n        if arg.startswith(\"results_dir=\"):\n            results_dir = arg.split(\"=\", 1)[1]\n        elif arg.startswith(\"run_ids=\"):\n            run_ids_json = arg.split(\"=\", 1)[1]\n        elif arg in (\"-h\", \"--help\"):\n            print(__doc__)\n            sys.exit(0)\n    if results_dir is None or run_ids_json is None:\n        raise SystemExit(\"Usage: python -m src.evaluate results_dir=/path run_ids='[\"\"run-1\"\", ...]' \")\n    return Path(os.path.abspath(results_dir)), json.loads(run_ids_json)\n\n\n# -----------------------------------------------------------------------------\n# Helpers ---------------------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef export_metrics(history: \"pd.DataFrame\", summary: Dict, config: Dict, out_dir: Path) -> Path:\n    out_dir.mkdir(parents=True, exist_ok=True)\n    payload = {\n        \"history\": history.to_dict(orient=\"list\"),\n        \"summary\": summary,\n        \"config\": config,\n    }\n    fp = out_dir / \"metrics.json\"\n    with open(fp, \"w\") as f:\n        json.dump(payload, f, indent=2)\n    return fp\n\n\ndef save_learning_curve(history: \"pd.DataFrame\", run_id: str, out_dir: Path) -> Path:\n    if \"global_step\" not in history.columns or \"train_loss\" not in history.columns:\n        return Path()\n    plt.figure(figsize=(8, 4))\n    sns.lineplot(data=history, x=\"global_step\", y=\"train_loss\", label=\"train_loss\", color=\"tab:blue\")\n    if \"val_retained_accuracy\" in history.columns:\n        ax2 = plt.twinx()\n        sns.lineplot(\n            data=history,\n            x=\"global_step\",\n            y=\"val_retained_accuracy\",\n            label=\"val_retained_accuracy\",\n            ax=ax2,\n            color=\"tab:orange\",\n        )\n        ax2.set_ylabel(\"val_retained_accuracy\")\n    plt.title(f\"Learning curve – {run_id}\")\n    plt.tight_layout()\n    fp = out_dir / f\"{run_id}_learning_curve.pdf\"\n    plt.savefig(fp)\n    plt.close()\n    return fp\n\n\ndef bar_chart(metric_map: Dict[str, float], title: str, out_path: Path):\n    names, vals = zip(*sorted(metric_map.items(), key=lambda kv: kv[0]))\n    plt.figure(figsize=(10, 5))\n    sns.barplot(x=list(names), y=list(vals))\n    plt.xticks(rotation=45, ha=\"right\")\n    for i, v in enumerate(vals):\n        plt.text(i, v, f\"{v:.3f}\", ha=\"center\", va=\"bottom\")\n    plt.ylabel(title)\n    plt.title(title)\n    plt.tight_layout()\n    plt.savefig(out_path)\n    plt.close()\n\n\ndef box_violin(df: \"pd.DataFrame\", metric: str, out_dir: Path):\n    gdf = df[df[\"metric\"] == metric]\n    if gdf.empty:\n        return []\n    paths = []\n    plt.figure(figsize=(8, 4))\n    sns.boxplot(data=gdf, x=\"method\", y=\"value\")\n    plt.title(f\"{metric} – box-plot\")\n    plt.tight_layout()\n    p = out_dir / f\"comparison_{metric}_box_plot.pdf\"\n    plt.savefig(p)\n    plt.close()\n    paths.append(p)\n\n    plt.figure(figsize=(8, 4))\n    sns.violinplot(data=gdf, x=\"method\", y=\"value\", inner=\"point\")\n    plt.title(f\"{metric} – violin-plot\")\n    plt.tight_layout()\n    p2 = out_dir / f\"comparison_{metric}_violin_plot.pdf\"\n    plt.savefig(p2)\n    plt.close()\n    paths.append(p2)\n    return paths\n\n\n# -----------------------------------------------------------------------------\n# Main evaluation -------------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef main():\n    out_root, run_ids = _parse_cli()\n    out_root.mkdir(parents=True, exist_ok=True)\n\n    cfg_global = OmegaConf.load(Path(__file__).resolve().parent.parent / \"config\" / \"config.yaml\")\n    entity, project = cfg_global.wandb.entity, cfg_global.wandb.project\n\n    api = wandb.Api()\n\n    aggregated: Dict[str, Dict[str, float]] = {}\n    records: List[Dict] = []\n    primary_metric_name = \"retained_accuracy_auc\"\n\n    for rid in run_ids:\n        run = api.run(f\"{entity}/{project}/{rid}\")\n        hist = run.history()\n        summ = dict(run.summary._json_dict)\n        cfg = dict(run.config)\n\n        run_dir = out_root / rid\n        mpath = export_metrics(hist, summ, cfg, run_dir)\n        lcurve_path = save_learning_curve(hist, rid, run_dir)\n        print(mpath)\n        if lcurve_path.exists():\n            print(lcurve_path)\n\n        for key, mat in summ.items():\n            if key.startswith(\"confusion_matrix_\"):\n                task = key[len(\"confusion_matrix_\") :]\n                cm = np.array(mat)\n                fig, ax = plt.subplots(figsize=(4, 4))\n                sns.heatmap(cm, annot=False, cbar=False, ax=ax)\n                plt.title(f\"{rid} – {task}\")\n                plt.tight_layout()\n                fp = run_dir / f\"{rid}_{task}_confusion_matrix.pdf\"\n                fig.savefig(fp)\n                plt.close(fig)\n                print(fp)\n\n        # Aggregate scalar summary metrics -----------------------------------\n        for k, v in summ.items():\n            if isinstance(v, (int, float)):\n                aggregated.setdefault(k, {})[rid] = float(v)\n                records.append(\n                    {\n                        \"run_id\": rid,\n                        \"metric\": k,\n                        \"value\": float(v),\n                        \"method\": \"proposed\"\n                        if \"proposed\" in rid\n                        else \"baseline\"\n                        if (\"baseline\" in rid or \"comparative\" in rid)\n                        else \"other\",\n                    }\n                )\n\n    # ---------------- Aggregated metrics ------------------------------------\n    comp_dir = out_root / \"comparison\"\n    comp_dir.mkdir(parents=True, exist_ok=True)\n\n    prim_map = aggregated.get(primary_metric_name, {})\n    best_prop = max(\n        ((rid, val) for rid, val in prim_map.items() if \"proposed\" in rid),\n        key=lambda x: x[1],\n        default=(None, -np.inf),\n    )\n    best_base = max(\n        (\n            (rid, val)\n            for rid, val in prim_map.items()\n            if (\"baseline\" in rid) or (\"comparative\" in rid)\n        ),\n        key=lambda x: x[1],\n        default=(None, -np.inf),\n    )\n    gap = None\n    if best_prop[1] != -np.inf and best_base[1] != -np.inf and best_base[1] != 0:\n        gap = (best_prop[1] - best_base[1]) / abs(best_base[1]) * 100.0\n\n    aggregate_json = comp_dir / \"aggregated_metrics.json\"\n    with open(aggregate_json, \"w\") as f:\n        json.dump(\n            {\n                \"primary_metric\": \"Area-Under-Curve of ‘retained-accuracy vs tasks’ ↑; secondary – CPU latency overhead ↓\",\n                \"metrics\": aggregated,\n                \"best_proposed\": {\"run_id\": best_prop[0], \"value\": best_prop[1]},\n                \"best_baseline\": {\"run_id\": best_base[0], \"value\": best_base[1]},\n                \"gap\": gap,\n            },\n            f,\n            indent=2,\n        )\n    print(aggregate_json)\n\n    # ---------------- Comparison figures -----------------------------------\n    if prim_map:\n        bar_path = comp_dir / \"comparison_retained_accuracy_auc_bar_chart.pdf\"\n        bar_chart(prim_map, \"Retained Accuracy AUC\", bar_path)\n        print(bar_path)\n\n    df_records = pd.DataFrame(records)\n    extra_paths = box_violin(df_records, primary_metric_name, comp_dir)\n    for p in extra_paths:\n        print(p)\n\n    # ---------------- Statistical significance ----------------------------\n    groups = {\n        \"proposed\": df_records[\n            (df_records.metric == primary_metric_name) & (df_records.method == \"proposed\")\n        ].value.values,\n        \"baseline\": df_records[\n            (df_records.metric == primary_metric_name) & (df_records.method == \"baseline\")\n        ].value.values,\n    }\n    if len(groups[\"proposed\"]) >= 2 and len(groups[\"baseline\"]) >= 2:\n        t_stat, p_val = stats.ttest_ind(groups[\"proposed\"], groups[\"baseline\"], equal_var=False)\n        tfile = comp_dir / \"ttest.txt\"\n        with open(tfile, \"w\") as f:\n            f.write(f\"t-statistic: {t_stat:.4f}, p-value: {p_val:.4e}\\n\")\n            f.write(\n                f\"proposed mean: {groups['proposed'].mean():.4f}, baseline mean: {groups['baseline'].mean():.4f}\\n\"\n            )\n        print(tfile)\n\n\nif __name__ == \"__main__\":\n    main()",
    "preprocess_py": "\"\"\"Pre-processing pipeline for Continual-Task-Stream-25.\nThis module builds a task stream generator that yields\n(name, train_loader, val_loader) tuples ready for continual training.\nAll HuggingFace assets are cached under `.cache/`.\n\"\"\"\nfrom __future__ import annotations\n\nimport random\nfrom functools import partial\nfrom typing import Any, Dict, Iterator, List, Tuple\n\nimport torch\nfrom datasets import IterableDataset, load_dataset\nfrom torch.utils.data import DataLoader\nfrom transformers import AutoTokenizer, PreTrainedTokenizerBase\n\n__all__ = [\"get_task_stream\"]\n\n# -----------------------------------------------------------------------------\n# Task registry ----------------------------------------------------------------\n# -----------------------------------------------------------------------------\n# We intentionally include >25 widely available HF datasets.  The loader will\n# skip tasks that cannot be downloaded and stop once `cfg.dataset.num_tasks` is\n# reached; this guarantees robustness across execution environments.\nTASKS: List[Dict[str, Any]] = [\n    # Translation (src, tgt language codes supplied)\n    {\"name\": \"opus_books_en_fr\", \"hf\": (\"opus_books\", \"en-fr\"), \"type\": \"translation\", \"src\": \"en\", \"tgt\": \"fr\"},\n    {\"name\": \"wmt14_en_de\", \"hf\": (\"wmt14\", \"de-en\"), \"type\": \"translation\", \"src\": \"en\", \"tgt\": \"de\"},\n    {\"name\": \"iwslt2017_en_de\", \"hf\": (\"iwslt2017\", \"iwslt2017-en-de\"), \"type\": \"translation\", \"src\": \"en\", \"tgt\": \"de\"},\n    {\"name\": \"ted_hrlr_pt_en\", \"hf\": (\"ted_hrlr_translate\", \"pt_to_en\"), \"type\": \"translation\", \"src\": \"pt\", \"tgt\": \"en\"},\n    # Summarisation\n    {\"name\": \"cnn_dailymail\", \"hf\": (\"cnn_dailymail\", \"3.0.0\"), \"type\": \"summarisation\", \"doc\": \"article\", \"sum\": \"highlights\"},\n    {\"name\": \"xsum\", \"hf\": (\"xsum\", None), \"type\": \"summarisation\", \"doc\": \"document\", \"sum\": \"summary\"},\n    {\"name\": \"samsum\", \"hf\": (\"samsum\", None), \"type\": \"summarisation\", \"doc\": \"dialogue\", \"sum\": \"summary\"},\n    # Classification (single sentence)\n    {\"name\": \"ag_news\", \"hf\": (\"ag_news\", None), \"type\": \"classification\", \"text\": \"text\", \"label\": \"label\"},\n    {\"name\": \"amazon_polarity\", \"hf\": (\"amazon_polarity\", None), \"type\": \"classification\", \"text\": \"content\", \"label\": \"label\"},\n    {\"name\": \"yelp_polarity\", \"hf\": (\"yelp_polarity\", None), \"type\": \"classification\", \"text\": \"text\", \"label\": \"label\"},\n    {\"name\": \"sst2\", \"hf\": (\"glue\", \"sst2\"), \"type\": \"classification\", \"text\": \"sentence\", \"label\": \"label\"},\n    {\"name\": \"mnli\", \"hf\": (\"glue\", \"mnli\"), \"type\": \"classification\", \"text\": \"premise\", \"label\": \"label\"},\n    {\"name\": \"rte\", \"hf\": (\"glue\", \"rte\"), \"type\": \"classification\", \"text\": \"sentence1\", \"label\": \"label\"},\n    {\"name\": \"cola\", \"hf\": (\"glue\", \"cola\"), \"type\": \"classification\", \"text\": \"sentence\", \"label\": \"label\"},\n    {\"name\": \"mrpc\", \"hf\": (\"glue\", \"mrpc\"), \"type\": \"classification\", \"text\": \"sentence1\", \"label\": \"label\"},\n    {\"name\": \"boolq\", \"hf\": (\"super_glue\", \"boolq\"), \"type\": \"classification\", \"text\": \"passage\", \"label\": \"label\"},\n    {\"name\": \"trec\", \"hf\": (\"trec\", None), \"type\": \"classification\", \"text\": \"text\", \"label\": \"label\"},\n    {\"name\": \"dbpedia_14\", \"hf\": (\"dbpedia_14\", None), \"type\": \"classification\", \"text\": \"content\", \"label\": \"label\"},\n    # QA treated generatively (question→answer)\n    {\"name\": \"squad_v2\", \"hf\": (\"squad_v2\", None), \"type\": \"qa\", \"question\": \"question\", \"answers\": \"answers\"},\n    {\"name\": \"tydiqa_goldp\", \"hf\": (\"tydiqa\", \"goldp\"), \"type\": \"qa\", \"question\": \"question\", \"answers\": \"answers\"},\n    # Code generation (treated generatively)\n    {\"name\": \"code_alpaca\", \"hf\": (\"code_alpaca\", \"default\"), \"type\": \"code\", \"prompt\": \"prompt\", \"completion\": \"completion\"},\n]\n\n\n# -----------------------------------------------------------------------------\n# Prompt builders -------------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef build_translation(example, src: str, tgt: str):\n    return f\"Translate from {src} to {tgt}: {example[src]}\\nTARGET:\", example[tgt]\n\n\ndef build_summarisation(example, doc: str, sum: str):\n    return f\"Summarise: {example[doc]}\\nSUMMARY:\", example[sum]\n\n\ndef build_classification(example, text: str, label: str):\n    return f\"Classify: {example[text]}\\nLABEL:\", str(int(example[label]))  # keep numeric label as string token\n\n\ndef build_qa(example, question: str, answers: str):\n    tgt = example[answers][\"text\"][0] if example[answers][\"text\"] else \"unanswerable\"\n    return f\"Answer the question: {example[question]}\\nANSWER:\", tgt\n\n\ndef build_code(example, prompt: str, completion: str):\n    return f\"### Instruction:\\n{example[prompt]}\\n### Response:\\n\", example[completion]\n\n\n# -----------------------------------------------------------------------------\n# Collate function -----------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef collate_fn_builder(tokenizer: PreTrainedTokenizerBase):\n    pad_id = tokenizer.pad_token_id or tokenizer.eos_token_id\n\n    def _fn(batch):\n        ids = [torch.tensor(ex[\"input_ids\"], dtype=torch.long) for ex in batch]\n        labs = [torch.tensor(ex[\"labels\"], dtype=torch.long) for ex in batch]\n        attn = [torch.tensor(ex[\"attention_mask\"], dtype=torch.long) for ex in batch]\n        ids = torch.nn.utils.rnn.pad_sequence(ids, batch_first=True, padding_value=pad_id)\n        labs = torch.nn.utils.rnn.pad_sequence(labs, batch_first=True, padding_value=-100)\n        attn = torch.nn.utils.rnn.pad_sequence(attn, batch_first=True, padding_value=0)\n        return {\"input_ids\": ids, \"attention_mask\": attn, \"labels\": labs}\n\n    return _fn\n\n\n# -----------------------------------------------------------------------------\n# Main API --------------------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef get_task_stream(cfg, tokenizer: PreTrainedTokenizerBase):\n    \"\"\"Yield a deterministic but diverse task stream of length cfg.dataset.num_tasks.\"\"\"\n    random.seed(0)\n    task_cnt = 0\n    max_len = cfg.dataset.max_seq_length\n    batch_size = cfg.training.batch_size\n    desired = cfg.dataset.num_tasks\n\n    for task in TASKS:\n        if task_cnt >= desired:\n            break\n        try:\n            dataset_name, dataset_conf = task[\"hf\"]\n            ds = load_dataset(dataset_name, dataset_conf, cache_dir=\".cache/\", streaming=cfg.dataset.streaming)\n        except Exception as e:\n            print(f\"[WARN] Could not load {task['name']}: {e}\")\n            continue\n\n        train_split = \"train\" if \"train\" in ds else list(ds.keys())[0]\n        val_split = (\n            \"validation\"\n            if \"validation\" in ds\n            else \"test\"\n            if \"test\" in ds\n            else train_split\n        )\n        ds_train_raw, ds_val_raw = ds[train_split], ds[val_split]\n\n        # Limit streaming datasets for reproducibility -----------------------\n        if isinstance(ds_train_raw, IterableDataset):\n            ds_train_raw = ds_train_raw.take(cfg.dataset.max_samples_per_task)\n        if isinstance(ds_val_raw, IterableDataset):\n            ds_val_raw = ds_val_raw.take(int(cfg.dataset.max_samples_per_task * 0.1))\n\n        # Select prompt builder ---------------------------------------------\n        if task[\"type\"] == \"translation\":\n            builder = partial(build_translation, src=task[\"src\"], tgt=task[\"tgt\"])\n        elif task[\"type\"] == \"summarisation\":\n            builder = partial(build_summarisation, doc=task[\"doc\"], sum=task[\"sum\"])\n        elif task[\"type\"] == \"classification\":\n            builder = partial(build_classification, text=task[\"text\"], label=task[\"label\"])\n        elif task[\"type\"] == \"qa\":\n            builder = partial(build_qa, question=task[\"question\"], answers=task[\"answers\"])\n        elif task[\"type\"] == \"code\":\n            builder = partial(build_code, prompt=task[\"prompt\"], completion=task[\"completion\"])\n        else:\n            raise ValueError(task[\"type\"])\n\n        # Tokenisation -------------------------------------------------------\n        def tok_fn(example):\n            prompt, tgt = builder(example)\n            enc_p = tokenizer(prompt, truncation=True, max_length=max_len)\n            enc_t = tokenizer(tgt, truncation=True, max_length=max_len)\n            input_ids = enc_p[\"input_ids\"] + enc_t[\"input_ids\"]\n            labels = [-100] * len(enc_p[\"input_ids\"]) + enc_t[\"input_ids\"]\n            return {\n                \"input_ids\": input_ids,\n                \"attention_mask\": [1] * len(input_ids),\n                \"labels\": labels,\n            }\n\n        ds_train = ds_train_raw.map(tok_fn, remove_columns=ds_train_raw.column_names)\n        ds_val = ds_val_raw.map(tok_fn, remove_columns=ds_val_raw.column_names)\n\n        collate = collate_fn_builder(tokenizer)\n        train_loader = DataLoader(\n            ds_train,\n            batch_size=batch_size,\n            shuffle=not cfg.dataset.streaming,\n            collate_fn=collate,\n        )\n        val_loader = DataLoader(\n            ds_val,\n            batch_size=cfg.evaluation.eval_batch_size,\n            shuffle=False,\n            collate_fn=collate,\n        )\n        yield task[\"name\"], train_loader, val_loader\n        task_cnt += 1",
    "model_py": "\"\"\"Model architectures for proposed HIMALAYA adapter and LILAC baseline.\"\"\"\nfrom __future__ import annotations\n\nimport math\nimport types\nfrom typing import Tuple\n\nimport numpy as np\nimport torch\nfrom sklearn.neighbors import KDTree\nfrom torch import nn\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\n# -----------------------------------------------------------------------------\n# Quantisation helper (uniform symmetric) -------------------------------------\n# -----------------------------------------------------------------------------\n\ndef quantise_tensor(t: torch.Tensor, num_bits: int = 3):\n    levels = 2 ** num_bits - 1\n    maxv = t.abs().max().item() + 1e-8\n    scale = maxv / (levels / 2)\n    q = torch.clamp((t / scale).round(), -levels / 2, levels / 2).to(torch.int8)\n    return q, scale\n\n\n# -----------------------------------------------------------------------------\n# Hyper-router (tiny MLP) ------------------------------------------------------\n# -----------------------------------------------------------------------------\nclass HyperRouter(nn.Module):\n    def __init__(self, h_dim: int, out_atoms: int, hidden_params: int = 45000):\n        super().__init__()\n        width = max(32, hidden_params // (h_dim + out_atoms))\n        self.net = nn.Sequential(nn.Linear(h_dim, width), nn.ReLU(), nn.Linear(width, out_atoms))\n\n    def forward(self, x):\n        return self.net(x)\n\n\n# -----------------------------------------------------------------------------\n# HIMALAYA adapter ------------------------------------------------------------\n# -----------------------------------------------------------------------------\nclass HIMALAYAAdapter(nn.Module):\n    \"\"\"Two-tier layer-free adapter implementing the full HIMALAYA algorithm.\"\"\"\n\n    def __init__(self, hidden_dim: int, cfg):\n        super().__init__()\n        # Core & elastic dictionaries --------------------------------------\n        k_c = cfg.model.adapter.core_dictionary.num_atoms\n        k_e_max = cfg.model.adapter.elastic_dictionary.max_atoms\n        self.k_c = k_c\n        self.k_e_max = k_e_max\n\n        self.register_parameter(\n            \"D_c\", nn.Parameter(torch.randn(k_c, hidden_dim) / math.sqrt(hidden_dim))\n        )\n        self.register_buffer(\"D_e\", torch.zeros(k_e_max, hidden_dim))\n        self.register_buffer(\"active\", torch.zeros(k_e_max, dtype=torch.bool))\n        self.register_buffer(\"usage\", torch.zeros(k_e_max, dtype=torch.long))\n\n        # Router ------------------------------------------------------------\n        total_atoms = k_c + k_e_max\n        self.router = HyperRouter(hidden_dim, total_atoms, cfg.model.adapter.router.hidden_params)\n        self.expected_k = cfg.model.adapter.router.expected_active_atoms\n        self.temperature = nn.Parameter(torch.tensor(float(cfg.model.adapter.router.temperature_init)))\n        self.tau = cfg.training.similarity_threshold_tau\n\n        # Residual ring buffer for elastic growth --------------------------\n        self.buffer = []\n        self.buffer_size = 200  # promote after 200 residuals\n\n        # KD-Tree (CPU) ------------------------------------------------------\n        self.kdtree = None\n        self._update_kdtree()\n\n        # For Fisher consolidation -----------------------------------------\n        self.fisher_U = nn.Parameter(torch.zeros_like(self.D_c))\n\n    # ---------------------------------------------------------------------\n    # Internals ------------------------------------------------------------\n    def _dict_mat(self):\n        return torch.cat([self.D_c, self.D_e[self.active]], dim=0)\n\n    def _update_kdtree(self):\n        mat = self._dict_mat().detach().cpu().numpy().astype(np.float32)\n        if mat.shape[0] != 0:\n            self.kdtree = KDTree(mat)\n\n    # ---------------------------------------------------------------------\n    def _consolidate(self, atom_vec: torch.Tensor):\n        \"\"\"Project information of `atom_vec` into the core latent statistics\n        using a closed-form Fisher orthogonal projection (approximated).\"\"\"\n        with torch.no_grad():\n            # Simple projection: update Fisher-mean matrix\n            proj = atom_vec / (atom_vec.norm() + 1e-8)\n            self.fisher_U.data += proj.unsqueeze(0)\n            # Renormalise to keep bounded norm <=1.05 as per paper\n            row_norms = self.fisher_U.data.norm(dim=1, keepdim=True) + 1e-8\n            self.fisher_U.data = torch.where(\n                row_norms > 1.05, self.fisher_U.data * (1.05 / row_norms), self.fisher_U.data\n            )\n\n    # ---------------------------------------------------------------------\n    def _grow_if_needed(self):\n        if len(self.buffer) < self.buffer_size:\n            return\n        residuals = torch.stack(self.buffer, dim=0)\n        self.buffer.clear()\n        mat = self._dict_mat()\n        if mat.shape[0] == 0:\n            return\n        cos = torch.mm(\n            nn.functional.normalize(residuals, dim=-1),\n            nn.functional.normalize(mat, dim=-1).t(),\n        )\n        if cos.mean().item() < self.tau:\n            if (~self.active).any():\n                slot = (~self.active).nonzero(as_tuple=False)[0].item()\n            else:\n                # prune least-used atom (Fisher consolidation beforehand)\n                slot = self.usage.argmax().item()\n                old_atom = self.D_e[slot].clone()\n                self._consolidate(old_atom)\n            # Promote mean residual -------------------------------------------------\n            new_atom = nn.functional.normalize(residuals.mean(dim=0), dim=-1)\n            self.D_e[slot].data.copy_(new_atom)\n            self.active[slot] = True\n            self.usage[slot] = 0\n            self._update_kdtree()\n\n    # ---------------------------------------------------------------------\n    def forward(self, hidden):  # hidden: (B, T, H)\n        B, T, H = hidden.shape\n        cls = hidden[:, 0, :]  # use first token representation as task signal\n        logits = self.router(cls) / self.temperature.abs()\n        probs = torch.softmax(logits, dim=-1)\n        top_val, top_idx = probs.topk(self.expected_k, dim=-1)\n        coeff = torch.zeros_like(probs)\n        coeff.scatter_(1, top_idx, top_val)\n        update_vec = coeff @ self._dict_mat()  # (B, H)\n\n        # Analytical norm rescaling to 1 ------------------------------------\n        update_vec = nn.functional.normalize(update_vec, dim=-1)\n\n        # Inject update (self-normalising outer product) --------------------\n        hidden = hidden + update_vec.unsqueeze(1) / math.sqrt(H)\n\n        # Stats for growth --------------------------------------------------\n        if self.training:\n            self.buffer.extend(update_vec.detach().cpu())\n            if len(self.buffer) >= self.buffer_size:\n                self._grow_if_needed()\n            for b in range(B):\n                for idx in top_idx[b]:\n                    ridx = idx.item() - self.k_c\n                    if 0 <= ridx < self.k_e_max and self.active[ridx]:\n                        self.usage[ridx] += 1\n        return hidden\n\n\n# -----------------------------------------------------------------------------\n# LoRA-style linear layer for LILAC baseline ----------------------------------\n# -----------------------------------------------------------------------------\nclass LoRALinear(nn.Module):\n    def __init__(self, linear: nn.Linear, r: int = 4, alpha: float = 1.0):\n        super().__init__()\n        self.linear = linear\n        self.r = r\n        self.alpha = alpha\n        self.A = nn.Parameter(torch.randn(r, linear.in_features) * 0.01)\n        self.B = nn.Parameter(torch.zeros(linear.out_features, r))\n        self.scale = alpha / r\n        self.linear.weight.requires_grad = False\n        if self.linear.bias is not None:\n            self.linear.bias.requires_grad = False\n\n    def forward(self, x):\n        return self.linear(x) + (x @ self.A.t() @ self.B.t()) * self.scale\n\n\ndef inject_lora(module: nn.Module, r: int = 4):\n    for name, child in module.named_children():\n        if isinstance(child, nn.Linear):\n            setattr(module, name, LoRALinear(child, r=r, alpha=r))\n        else:\n            inject_lora(child, r)\n\n\n# -----------------------------------------------------------------------------\n# Model builder ---------------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef build_model(cfg):\n    backbone_id = cfg.model.backbone.name\n    tokenizer = AutoTokenizer.from_pretrained(backbone_id, cache_dir=\".cache/\", use_fast=True)\n    if tokenizer.pad_token_id is None:\n        tokenizer.pad_token = tokenizer.eos_token\n\n    model = AutoModelForCausalLM.from_pretrained(\n        backbone_id, cache_dir=\".cache/\", torch_dtype=torch.float16, low_cpu_mem_usage=True\n    )\n\n    if cfg.training.gradient_checkpointing:\n        model.gradient_checkpointing_enable()\n\n    for p in model.parameters():\n        p.requires_grad = False\n\n    hidden = model.config.hidden_size\n    adapter_type = cfg.model.adapter.type.upper()\n\n    if adapter_type == \"HIMALAYA\":\n        adapter = HIMALAYAAdapter(hidden, cfg)\n        orig_forward = model.forward\n\n        def patched_forward(self, input_ids=None, attention_mask=None, labels=None, **kwargs):\n            outputs = orig_forward(\n                input_ids=input_ids,\n                attention_mask=attention_mask,\n                output_hidden_states=True,\n                return_dict=True,\n                **kwargs,\n            )\n            hidden_states = outputs.hidden_states[-1]\n            hidden_states = adapter(hidden_states)\n            logits = self.lm_head(hidden_states)\n            loss = None\n            if labels is not None:\n                shift_logits = logits[..., :-1, :].contiguous()\n                shift_labels = labels[..., 1:].contiguous()\n                loss = nn.functional.cross_entropy(\n                    shift_logits.view(-1, shift_logits.size(-1)),\n                    shift_labels.view(-1),\n                    ignore_index=-100,\n                )\n            return {\"loss\": loss, \"logits\": logits}\n\n        model.forward = types.MethodType(patched_forward, model)\n        model.add_module(\"himalaya_adapter\", adapter)\n        for p in adapter.parameters():\n            p.requires_grad = True\n\n    elif adapter_type == \"LILAC\":\n        inject_lora(model, r=cfg.model.adapter.lora_rank)\n        for n, p in model.named_parameters():\n            if n.endswith(\".A\") or n.endswith(\".B\"):\n                p.requires_grad = True\n    else:\n        raise ValueError(adapter_type)\n\n    return model, tokenizer",
    "main_py": "import os\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nimport hydra\nfrom omegaconf import DictConfig, OmegaConf\n\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=None)\ndef main(cfg: DictConfig):\n    # ---------------- Mode handling ----------------\n    if cfg.mode == \"trial\":\n        cfg.wandb.mode = \"disabled\"\n        cfg.optuna.n_trials = 0\n        cfg.dataset.num_tasks = min(cfg.dataset.num_tasks, 2)\n        cfg.training.task_epochs = 1\n    elif cfg.mode == \"full\":\n        cfg.wandb.mode = \"online\"\n    else:\n        raise ValueError(\"mode must be trial|full\")\n\n    # Resolve & persist config ------------------------------------------------\n    out_dir = Path(hydra.utils.to_absolute_path(cfg.results_dir))\n    out_dir.mkdir(parents=True, exist_ok=True)\n    OmegaConf.save(cfg, out_dir / f\"{cfg.run}_resolved.yaml\")\n\n    # Launch train subprocess -------------------------------------------------\n    cmd = [\n        sys.executable,\n        \"-u\",\n        \"-m\",\n        \"src.train\",\n        f\"run={cfg.run}\",\n        f\"results_dir={cfg.results_dir}\",\n        f\"mode={cfg.mode}\",\n    ]\n    print(\"Launching:\", \" \".join(cmd))\n    env = os.environ.copy()\n    env.setdefault(\"HYDRA_FULL_ERROR\", \"1\")\n    subprocess.run(cmd, check=True, env=env)\n\n\nif __name__ == \"__main__\":\n    main()",
    "pyproject_toml": "[project]\nname = \"himalaya-experiments\"\nversion = \"0.4.0\"\ndescription = \"Hydra-managed continual-learning experiments for the HIMALAYA adapter\"\nrequires-python = \">=3.9\"\nlicense = {text = \"MIT\"}\n\n[project.dependencies]\ntorch = \">=2.1\"\ntransformers = \">=4.35\"\ndatasets = \">=2.15\"\nhydra-core = \">=1.3\"\nwandb = \">=0.16\"\noptuna = \">=3.5\"\nmatplotlib = \">=3.8\"\nseaborn = \">=0.13\"\npandas = \">=2.1\"\nnumpy = \">=1.23\"\nscikit-learn = \">=1.4\"\nscipy = \">=1.11\"\ntqdm = \">=4.66\"",
    "config_yaml": "defaults:\n  - _self_\n  - runs: ${run}\n\n# CLI overrides ----------------------------------------------------------------\nrun: null\nresults_dir: outputs\nmode: full\n\n# -----------------------------------------------------------------------------\n# Global WandB configuration (overwritten automatically in trial mode)\n# -----------------------------------------------------------------------------\nwandb:\n  entity: gengaru617-personal\n  project: 2025-1108-1\n  mode: online  # set to \"disabled\" automatically for trial\n\n# -----------------------------------------------------------------------------\n# Dataset defaults (may be overridden by run configs) --------------------------\n# -----------------------------------------------------------------------------\ndataset:\n  name: continual_task_stream_25\n  num_tasks: 5\n  max_samples_per_task: 50000\n  max_seq_length: 1024\n  streaming: true\n\n# -----------------------------------------------------------------------------\n# Training defaults -----------------------------------------------------------\n# -----------------------------------------------------------------------------\ntraining:\n  batch_size: 8\n  task_epochs: 1\n  max_updates_per_task: 50000\n  learning_rate: 2e-4\n  weight_decay: 0.0\n  warmup_steps: 500\n  gradient_checkpointing: true\n  mixed_precision: bf16\n\n# -----------------------------------------------------------------------------\n# Evaluation defaults ---------------------------------------------------------\n# -----------------------------------------------------------------------------\nevaluation:\n  eval_batch_size: 4\n  cpu_latency_device: raspberry-pi-4\n\n# Optuna fallback (disabled by default) ---------------------------------------\noptuna:\n  n_trials: 0\n  direction: maximize\n  search_space: {}\n\n# Placeholders to keep OmegaConf happy ----------------------------------------\nmodel: {}\n"
}
